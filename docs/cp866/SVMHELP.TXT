.topic NoContext=0
 ───────── Информационная система ─────────

   Извините,   но  для  данного  раздела в
 информационной   системе   информация  не
 предусмотренна.        Обратитесь       в
 {главное меню информационной системы:InfoSystem} или
 к {общему списку:MainList}.

   Нажмите    ESC    чтобы   убрать   окно
 информационной системы.

.topic ShAGLogo
 ─ Справочная информация ─────────────────

   Приветствую  Вас  в моей информационной
 системе.
   Меня  зовут Штокало Алексей Геннадиевич
 (Shtokalo  Alexey Gennadievich - отсуда и
 абривиатура  ShAG).  Я  ученик  11 класса
 физико-математической   школы  #1  города
 Луганска.  Будичи  учеником  11 класса, я
 как  и  все  забочусь  о том, куда я буду
 поступать.  Но имея 3 по ураинскому языку
 я врядли напишу вступительные экзамены (а
 может   и   напишу).   Поэтому   я  решил
 "проползти"  в институт по собеседыванию.
 В   качестве   способа   я  избрал  Малую
 академию  наук.  Поэтому если к Вам попал
 полный  пакет  программ  объединенных под
 названием  SVM (ShAG Virtual Machina), то
 Вы  должны знать, что это работа, которую
 я буду представлять на защите.
   Хочу добавить, что ShAG Studio - это не
 фирма,  просто  так  я назвал себя и свой
 компьютер    (Intel   80x286-16   1Mb/VGA
 256Kb/Mono 11.8"/HDD 96Mb/FDD 5.25" - без
 понтов  -  на  этой  машине я написал всю
 свою  работу - все, что входит в комплект
 SVM,   -  за  5  месяцев).  Моэтому  если
 встретите  прогаммы  с  таким копирайтом,
 знайте - это Я.
   Кстати,     если    найдете    какие-то
 граматические   или  программные  ошибки,
 не  обижайтесь.  Поймите  меня правильно,
 все это я писал обычно в вечернее, ночное
 время  -  сами понимаете - учеба. Поэтому
 просьба,   о   всех   найденныйх   глюках
 сообщите мне (ниже мои координаты) о них.
   Заходите  комне  на сайт. Там Вы всегда
 сможете найти самые последние версии моих
 программ  с  полной  документацией.  Если
 чего надо - пишите.

 ─────────────────────────────────────────
 Мои координаты:
 http://www.shag.itgo.com
 shag@qnx.com
 г. Луганск, кв. Шевченко, дом 48-а/33.
 ─────────────────────────────────────────
                   :-)


.topic MRun
 ─ Меню Run ──────────────────────────────

   Это  меню  содержит  пункты, управления
 запуском программы на исполнение.

 Комбинация клавиш: Alt-R

 Смотри также:
  {Запуск на исполнение:Run}
  {отладчик:Debugger}

  {главное меню информационной системы:InfoSystem}

.topic Run
 ─ Пункт Run>Run ─────────────────────────

   Этот  пункт запускает главную программу
 на   исполнение.  Если  главный  файл  не
 компилировался    или   изменялся   после
 последней  компиляции,  то перед запуском
 на          исполнение        запускается
 {процесс компиляции:Compile}   и   только   если
 компиляция    была   успешно   завершена,
 запускается    Ваша    программа.   Перед
 запуском    вашей   программы,   оболочка
 переключается на {пользовательский экран:UserScreen},
 чтобы затем Вы смогли увидеть  результаты
 работы вашей программы.

 Комбинация клавиш: Ctrl-F9

 Смотри также:
  {Установить главный файл:SetPF}
  {Сбросить главный файл:ClearPF}
  {Экран пользователя:UserScreen}
  {отладчик:Debugger}

  {главное меню информационной системы:InfoSystem}


.topic Debugger
 ─ Пункт Run>Debugger ────────────────────

   Этот пункт запускает {отладчик:DebuggerInfo}, который
 загружает   главный   файл   и  позволяет
 исполнять  его  пошагово  с  отображением
 регистров   и   стека.   Главная   задача
 отладчик   помочь  Вам  найти  допущенные
 где-то  ошибки, что вручную сделать очень
 трудно.     Если    главный    файл    не
 компилировался    или   изменялся   после
 последней  компиляции,  то перед запуском
 отладчика запускается {процесс компиляции:Compile}
 и   только  после  этого, если компиляция
 была   успешно   завершена,   запускается
 отладчик.   Перед   запуском   отладчика,
 оболочка         переключается         на
 {пользовательский экран:UserScreen}, чтобы затем
 Вы смогли увидеть результаты работы вашей
 программы под управлением отладчика.

 Комбинация клавиш: F8

 Смотри также:
  {Установить главный файл:SetPF}
  {Сбросить главный файл:ClearPF}
  {Экран пользователя:UserScreen}
  {Запуск на исполнение:Run}

  {главное меню информационной системы:InfoSystem}










.topic MHelp
 ─ Меню Help ─────────────────────────────

   Это  меню  содержит  пункты,  с помощью
 которых   вы   сможете   быстро  получить
 нужную вам информацию.

 Комбинация клавиш: Alt-H

 Смотри также:
  {Общий список:MainListH}
  {главное меню информационной системы:InfoSystemH}
  {О программе:About}

.topic InfoSystemH
 ─ Пункт Help>Contents ───────────────────

   Этот пункт вызывает главное меню службы
 справки.   С   его   помощью  Вы  сможете
 получить   доступ   ко  всей  информации,
 которая  храниться в файле помощи. Выбрав
 {этот выделенный пункт:InfoSystem}, Вы также сможете
 попасть в это меню.

.topic MainListH
 ─ Пункт Help>Index ──────────────────────

   Этот  пункт  вызывает алфавитный список
 всех    доступных    справок    в    этой
 информационной        службе.      Выбрав
 {этот выделенный пункт:MainList}, Вы также сможете
 попасть в это список.

 Комбинация клавиш: Shift-F1

 Смотри также:

  {главное меню информационной системы:InfoSystem}

.topic About
 ─ Пункт Help>About... ───────────────────

   Выбрав  этот  пункт Вы сможете получить
 информацию  о  версии,  названии и авторе
 этой прогаммы.

 Смотри также:

  {главное меню информационной системы:InfoSystem}













.topic MainList

 Список всех доступных для вызова справок:

  A                    C
  {AND}                  {CALL}
  {ADD}                  {CMP}
                       {CSP}
                       {CL<флаг>:CLf}

  D                    I
  {DEC}                  {INC}
  {DIV}

  J                    M
  {JMP}                  {MOV}
  {JRNZ}                 {MUL}
  {JRZ}
  {J<условие>:Jif}
  {JN<условие>:JNif}

  N                    O
  {NEG}                  {OR}
  {NOP}
  {NOT}

  P                    R
  {PUSH}                 {RET}
  {POP}

  S                    T
  {SUB}                  {TEST}
  {ST<флаг>:STf}

  X
  {XCHG}
  {XOR}

  Б
  {Буффер обмена:TextBuffer}

  В
  {Виртуальная машина:VM}
  {Вставить блок:Paste}
  {Вырезать блок:Cut}
  {Выход:Exit}

  Г
  {Главное меню информационной системы:InfoSystemH}
  {Главный файл:MainFile}

  Д
  {отладчик:Debugger}
  {отладчик - это...:DebuggerInfo}

  З
  {Закрыть все окна:CloseAll}
  {Закрыть окно:Close}
  {Замена текста:Replace}
  {Запуск на компиляцию:Compile}

  И
  {Изменить размер окна:Resize}

  К
  {Калькулятор:Calculator}
  {Карта памяти:MAPFile}
  {Каталоги:Directories}
  {Копировать блок:Copy}
  {Команды виртуального процессора:ComVP}
  {Команды встроенного редактора:EditCom}

  М
  {Меню и горячие клавиши:MHK}

  Н
  {Новый:New}

  О
  {О программе:About}
  {Общий список:MainListH}
  {Окно информации:Information}
  {Открыть:Open}
  {Отменить последнее действие:Undo}

  П
  {Память и стек:MandS}
  {Подключаемые файлы:INCFile}
  {Поиск текста:Find}
  {Помощь по информационной системе:InfoSysHelp}
  {Посмотреть содержимое буффера обмена:ShowClipboard}
  {Предыдущее окно:Previous}
  {Продолжение поиска:SearchAgain}

  Р
  {Разместь все окна каскадом:Cascade}
  {Разместь все окна одновременно:Tile}
  {Регистры и флаги:RegVP}
  {Режим командной строки:DosShell}

  С
  {Сбросить главный файл:ClearPF}
  {Следующее окно:Next}
  {Сменить каталог:ChangeDir}
  {Сообщения:Message}
  {Сохранить:Save}
  {Сохранить как:SaveAs}
  {Сохранить все:SaveAll}
  {Список окон:WindowList}

  Т
  {Текстовый блок:TextBlock}
  {Текстовый курсор:TextCursor}

  У
  {Увеличть/уменьшить окно:Zoom}
  {Удалить блок:Clear}
  {Установить главный файл:SetPF}

  Ф
  {Файл подкачки:SWPFile}

  Э
  {Экран пользователя:UserScreen}

  ┌─────────────┐
  │ {ShAG Studio:ShAGLogo} │
  └─────────────┘



















.topic InfoSysHelp
 ─ Помощь по информационной системе ──────

   Информационная   система   представляет
 собой    набор   справок   по   отдельным
 компонентам.  Одно из лучших качеств этой
 системы    -    Вы   имеете   возможность
 управляемо   перемещаться   среди   всего
 этого    объема    информации.    Поэтому
 ознакомившись   с   навыками  навигации в
 информационной  системе  Вам  не составит
 труда   отыскать   в   ней   нужную   Вам
 информацию.

 Клавиши управления информационной системой.
 ───────────────────────────────────────────
 Tab       - выбрать следующий пункт
 Shift-Tab - выбрать предыдущий пункт
 Enter     - перейти на страницу выбранного
             пункта
 Alt-F1    - вернуться на страницу с которой
             был осуществлен переход на
             выбранную в данный момент
 Esc       - покинуть информационную систему

   Как видите объем клавиш для запоминания
 очень  мал.  Теперь  поясню то, что может
 быть Вам не понятно:
   пункт  - пунктом я называю часть текста
 фон  которого подсвечена другим цветом. В
 наверника  уже  видели  такие пункты. Эти
 пункты   указывают   на  другие  страницы
 информационной службы. Выбрав такой пункт
 и нажав клавишу Enter Вы переместитесь на
 страницу,   которая   связанна   с  таким
 указателем;
   страница  - окно информационной системы
 всегда   показывает   какую-то  страницу.
 Указатели  указывают  на  такие страницы.
 Каждая  страница  посвящается  конкретной
 теме.   Это   дает   возможность   удобно
 структурировать информацию содержащююся в
 этой информационной системе.
   выбор   пункта   -  эту  фразу  следует
 понимать  как  сделайте  так,  чтобы цвет
 символов  нужного  Вам  пункта  светились
 цветом, отличным от цвета символов других
 пунктов.     Для    этого    вы    можете
 использовать    клавишу    Tab,   которая
 циклически    перемещается   среди   всех
 пунктов страницы.

   Ознакомившись   с  данной  страницей, я
 думаю,  что теперь Вы сможете без особого
 труда  перемещаться в этой информационной
 системе.

                  5 января 2000 года.
                  Штокало Алексей Геннадиевич


.topic MHK
 ─ Меню и горячие клавиши ────────────────

   В    оболочке    предназначенной    для
 написания  программ  на  языке ассемблере
 под   виртуальную   машину   SVM  имеются
 следующие меню: {File:MFile}, {Edit:MEdit}, {Search:MSearch}, {Run:MRun},
 {Compile:MCompile}, {Tools:MTools}, {Options:MOptions}, {Windows}, {Help:MHelp}.
   Если   Вы  переместитесь  по  указанным
 пунктам,    то    Вы   сможете   узнать о
 содержании и назначении этих пунктов.

 Горячие клавиши оболочки.
 ─────────────────────────────────────────
 Alt-X    - покинуть оболочку
 F1       - вызвать информационную систему
 F9       - откомпилировать и запустить
            программу
 F8       - запустить {отладчик:Debugger}
 Ctrl-F9  - запустить программу
 Alt-F9   - откомпилировать прогамму
 F2       - сохранить текст
 F3       - открыть файл
 Shift-F1 - вызвать алфавитный список всех
            доступных справок

   Попбродив  по информационной системе Вы
 сможете  найти  более  детальной описание
 всех выше указанных комбинаций.

.topic EditCom
 ─ Команды встроенного редактора ─────────

   Оболочка  содержит  встроенный редактор
 текстов,    который    предназначен   для
 написания   программ.   Чтобы   Вы  могли
 эффективно     использовать    все    его
 возможности Вы должны ознакомиться с этой
 страницей.

 Горячие клавиши редактора.
 ─────────────────────────────────────────
 Arrow key   - перемещение {курсора:TextCursor}
 PgUp        - страницу вверх
 PgDown      - страницу вниз
 Home        - в начало строки
 End         - в конец строки
 Ctrl-Left   - на слово влево
 Ctrl-Right  - на слово вправо
 Ctrl-Home   - на первую строку экрана
 Ctrl-End    - на последнюю строку экрана
 Ctrl-PgUp   - в начало текста
 Ctrl-PgDown - в конец тексты
 Ctrl-K+H    - снять выделение
 Ctrl-Y      - удалить строку с курсором

   Попбродив  по информационной системе Вы
 сможете  найти  более  детальной описание
 всех  выше  указанных комбинаций. Советую
 также  посетить страницы описывающие меню
 {Редактирование:MEdit} и {Поиск:MSearch}.  На них  Вы
 найдете полезную при работе информацию.

.topic InfoSystem
 ─────────────────────────────────────────────
 ──── Главное меню информационной системы ────
 ─────────────────────────────────────────────

 {Помощь по информационной системе:InfoSysHelp}
 {Меню и горячие клавиши:MHK}
 {Команды встроенного редактора:EditCom}

 Интерактивный учебник по ассемблеру:
 {Виртуальная машина:VM}
 {Регистры и флаги:RegVP}
 {Память и стек:MandS}
 {Команды виртуального процессора:ComVP}

 Copyright (c) 1999,2000           ShAG Studio
 ─────────────────────────────────────────────













.topic MCompile
 ─ Меню Compile ──────────────────────────

   Это  меню  содержит  пункты, управления
 процессом компиляции.

 Комбинация клавиш: Alt-C

 Смотри также:
  {Запуск на компиляцию:Compile}
  {Установить главный файл:SetPF}
  {Сбросить главный файл:ClearPF}

  {главное меню информационной системы:InfoSystem}


.topic Compile
 ─ Пункт Compile>Compile ─────────────────

   Этот     пункт     запускает    процесс
 компиляции.  Вы  должны  учесть,  что  во
 время  процесса  компиляции  оболочка  не
 работает,    так    как    она   вызывает
 стандартный компилятор, который имитирует
 оболочку  и  интерфейс Turbo Vision. Если
 вы  захотите прервать процесс компиляции,
 вы   должны   нажать  кнопку  Esc.  Чтобы
 компиляция прошла успешно, у Вас на диске
 должно быть свободно не менее 1 мегабайта
 и  все  каталоги  должны  быть  прописаны
 верно.

 Комбинация клавиш: Alt-F9

 Смотри также:
  {Установить главный файл:SetPF}
  {Сбросить главный файл:ClearPF}
  {отладчик:Debugger}

  {главное меню информационной системы:InfoSystem}


.topic SetPF
 ─ Пункт Compile>Primary file... ─────────

   Этот     пункт     позволяет    выбрать
 {главный файл:MainFile} для правильной работы всей
 оболочки.

 Комбинация клавиш: Alt-P

 Смотри также:
  {Запуск на компиляцию:Compile}
  {Сбросить главный файл:ClearPF}

  {главное меню информационной системы:InfoSystem}


.topic ClearPF
 ─ Пункт Compile>Clear primary file ──────

Этот пункт позволяет сбросить {главный файл:MainFile}.

 Комбинация клавиш: Alt-L

 Смотри также:
  {Запуск на компиляцию:Compile}
  {Установить главный файл:SetPF}

  {главное меню информационной системы:InfoSystem}















.topic MFile
 ─ Меню File ─────────────────────────────

   В  этом  меню содержаться пункты дающие
 доступ к файловым функциям.

 Комбинация клавиш: Alt-F

 Смотри также:
  {Новый:New}
  {Открыть:Open}
  {Сохранить:Save}
  {Сохранить как:SaveAs}
  {Сохранить все:SaveAll}
  {Сменить каталог:ChangeDir}
  {Режим командной строки:DosShell}
  {Выход:Exit}

  {главное меню информационной системы:InfoSystem}


.topic Open
 ─ Пункт File>Open ───────────────────────

   С   помощью  этого  пункта,  вы  можете
 открыть   новый   файл   для   текстового
 редактора.   По   умолчанию   вы  сможете
 выбрать  файл  имеющий расширение asm, но
 изменив  расширение,  вы  сожете  открыть
 любой   файл.   После   открытия   файла,
 программа  создаст  новое текстовое окно,
 в  котором  будет  находиться  содержимое
 файла.

 Комбинация клавиш: F3

 Смотри также:
  {Новый:New}
  {Сохранить:Save}
  {Сохранить как:SaveAs}
  {Сохранить все:SaveAll}
  {Сменить каталог:ChangeDir}
  {Режим командной строки:DosShell}
  {Выход:Exit}

  {главное меню информационной системы:InfoSystem}


.topic New
 ─ Пункт File>New ────────────────────────

   Этот пункт создает новое текстовое окно
 с  именем  "Untitled", для того, чтобы Вы
 могли  написать  новую программу, а затем
 сохранить    её    с    помощью   функции
 {Сохранить:Save} или {Сохранит как:SaveAs}.

 Комбинация клавиш: Alt-N

 Смотри также:
  {Открыть:Open}
  {Сохранить:Save}
  {Сохранить как:SaveAs}
  {Сохранить все:SaveAll}
  {Сменить каталог:ChangeDir}
  {Режим командной строки:DosShell}
  {Выход:Exit}

  {главное меню информационной системы:InfoSystem}


.topic Save
 ─ Пункт File>Save ───────────────────────

   Этот  пункт сохраняет в файл содержимое
 активного   окна.  Если  до  этого  текст
 окна  был не сохранен, то появляется меню
 предлагающее  сохранить  содержимое  окна
 в файл. Появляющееся окно аналогично окну
 из пункта {Сохранит как:SaveAs}.

 Комбинация клавиш: F2

 Смотри также:
  {Новый:New}
  {Открыть:Open}
  {Сохранить как:SaveAs}
  {Сохранить все:SaveAll}
  {Сменить каталог:ChangeDir}
  {Режим командной строки:DosShell}
  {Выход:Exit}

  {главное меню информационной системы:InfoSystem}


.topic SaveAs
 ─ Пункт File>Save as ────────────────────

   Этот  пункт  позволяет сохранить текст,
 уже сохраненный в файл, в новый файл.

 Комбинация клавиш: нет

 Смотри также:
  {Новый:New}
  {Открыть:Open}
  {Сохранить:Save}
  {Сохранить все:SaveAll}
  {Сменить каталог:ChangeDir}
  {Режим командной строки:DosShell}
  {Выход:Exit}

  {главное меню информационной системы:InfoSystem}


.topic SaveAll
 ─ Пункт File>Save all ───────────────────

   Этот   пункт  позволяет  сохранить  все
 открытые текст.

 Комбинация клавиш: Alt-F2

 Смотри также:
  {Новый:New}
  {Открыть:Open}
  {Сохранить:Save}
  {Сохранить как:SaveAs}
  {Сменить каталог:ChangeDir}
  {Режим командной строки:DosShell}
  {Выход:Exit}

  {главное меню информационной системы:InfoSystem}


.topic ChangeDir
 ─ Пункт File>Chande dir ─────────────────

   Этот  пункт  позволяет сменить каталог,
 который     будет    использоваться    по
 умолчанию.

 Комбинация клавиш: нет

 Смотри также:
  {Новый:New}
  {Открыть:Open}
  {Сохранить:Save}
  {Сохранить как:SaveAs}
  {Сохранить все:SaveAll}
  {Режим командной строки:DosShell}
  {Выход:Exit}

  {главное меню информационной системы:InfoSystem}


.topic DosShell
 ─ Пункт File>Dos shell ──────────────────

   Этот  пункт  позволяет  выйти  в  режим
 DOS'a   -   в   командную  строку.  Чтобы
 вернуться    в    программу,   напишите в
 командной строке слово Exit.

 Комбинация клавиш: нет

 Смотри также:
  {Новый:New}
  {Открыть:Open}
  {Сохранить:Save}
  {Сохранить как:SaveAs}
  {Сохранить все:SaveAll}
  {Сменить каталог:ChangeDir}
  {Выход:Exit}

  {главное меню информационной системы:InfoSystem}


.topic Exit
 ─ Пункт File>Exit ───────────────────────

 Этот пункт завершает работу программы.

 Комбинация клавиш: Alt-X

 Смотри также:
  {Новый:New}
  {Открыть:Open}
  {Сохранить:Save}
  {Сохранить как:SaveAs}
  {Сохранить все:SaveAll}
  {Сменить каталог:ChangeDir}
  {Режим командной строки:DosShell}

  {главное меню информационной системы:InfoSystem}














.topic MTools
 ─ Меню Tools ────────────────────────────

   Это    меню    позволяет   использовать
 дополнительные  функции оболочки, которые
 созданы   с   целью  облегчить  и  сделть
 удобной Вашу работу.

 Комбинация клавиш: Alt-T

 Смотри также:
  {Калькулятор:Calculator}
  {Экран пользователя:UserScreen}
  {Сообщения:Message}
  {Окно информации:Information}

  {главное меню информационной системы:InfoSystem}


.topic UserScreen
 ─ Пункт Tools>User screen ───────────────

   Этот  пункт позволяет Вам просматривать
 второй   текстовый   экран.  При  запуске
 оболочки,  делается  копия  экрана, а при
 дальнейшей работе этот экран используется
 как  основной.  Это  позволяет работать в
 оболочке   и  выдеть  экран  операционной
 системы,  на  который  осуществляют вывод
 все  другие  программы, в том числе и те,
 которые написали Вы.

 Комбинация клавиш: Alt-F5

 Смотри также:
  {Калькулятор:Calculator}
  {Сообщения:Message}
  {Окно информации:Information}

  {главное меню информационной системы:InfoSystem}


.topic Calculator
 ─ Пункт Tools>Calculator ────────────────

   Этот пункт позволяет вызвать встроенный
 калькулятор.    Встроенный    калькулятор
 имеет  ограниченные возможности. Он может
 выполнять    все    простейшие   операции
 (сложение, вычитание, умножение, деление)
 над  числами любого типа. Так же он может
 менять  знак  числа  на  противоположный,
 удалять     крайний    символ    справа и
 сбрасывать результат вычислений. Работать
 с  калькулятором  можно как с клавиатуры,
 так и с помощью манипулятора типа "мышь".

 Комбинация клавиш: Ctrl-F4

 Смотри также:
  {Экран пользователя:UserScreen}
  {Сообщения:Message}
  {Окно информации:Information}

  {главное меню информационной системы:InfoSystem}


.topic Message
 ─ Пункт Tools>Messages... ───────────────

   Этот  пункт  позволяет  просмотреть все
 сообщения   для   файла,  который  сейчас
 является главным.

 Комбинация клавиш: Alt-M

 Смотри также:
  {Калькулятор:Calculator}
  {Экран пользователя:UserScreen}
  {Окно информации:Information}

  {главное меню информационной системы:InfoSystem}


.topic Information
 ─ Пункт Tools>Information... ────────────

   Этот    пункт   позволяет   просмотреть
 информацию   о   результатах  компиляции.
 Также,   окно,  которое  возникнет  после
 выбора     этого     пункта,     содержит
 информацию   о   объеме   памяти   Вашего
 компьютера,  о  объеме  свободной памяти,
 название        Вашего       процессора и
 сопроцессора.

 Комбинация клавиш: Alt-I

 Смотри также:
  {Калькулятор:Calculator}
  {Экран пользователя:UserScreen}
  {Сообщения:Message}


  {главное меню информационной системы:InfoSystem}





.topic MOptions
 ─ Меню Options ──────────────────────────

   Это   меню  содержит  команды  нстройки
 оболочки.

 Комбинация клавиш: Alt-O

 Смотри также:
  {Каталоги:Directories}

  {главное меню информационной системы:InfoSystem}


.topic Directories
 ─ Пункт Options>Directories ─────────────

   Этот   пункт   позволяет   Вам   задать
 местоположения   компилятора,  эмулятора,
 отладчика, {подключаемых файлов:INCFile}, каталог
 в   котором   будут   сохранятся   файлы,
 содержащие     {карты    памяти:MAPFile}, каталог
 в  котором   будут  сохранятся результаты
 компиляции,  а    также позволяет  задать
 диск    на    котором    можно  создавать
 {файл подкачки:SWPFile}.

 Смотри также:

  {главное меню информационной системы:InfoSystem}











.topic Windows
 ─ Меню Windows ──────────────────────────

   Это  меню  содержит  команды, с помощью
 которых Вы можете управлять окнами.

 Комбинация клавиш: Alt-W

 Смотри также:
  {Разместь все окна одновременно:Tile}
  {Разместь все окна каскадом:Cascade}
  {Закрыть все окна:CloseAll}
  {Изменить размер окна:Resize}
  {Увеличть/уменьшить окно:Zoom}
  {Следующее окно:Next}
  {Предыдущее окно:Previous}
  {Закрыть окно:Close}
  {Список окон:WindowList}

  {главное меню информационной системы:InfoSystem}


.topic Resize
 ─ Пункт Windows>Resize ──────────────────

   Этот  пункт  позволяет  изменять размер
 окна.   Это   можно   делать   мышью  или
 клавиатурой.  Чтобы  изменять размер окна
 клавиатурой  удерживайте  клавишу Shift и
 курсором        изменяйти        размер в
 соответствующем     направлении.    Чтобы
 изменить   положение   окна   клавиатурой
 удерживайте   клавишу   Ctrl  и  курсором
 двигайте окно в нужном направлении. После
 того,  как  Вы изменить то, что Вам нужно
 нажмите клавишу Enter.

 Комбинация клавиш: Ctrl-F5

 Смотри также:
  {Разместь все окна одновременно:Tile}
  {Разместь все окна каскадом:Cascade}
  {Закрыть все окна:CloseAll}
  {Увеличть/уменьшить окно:Zoom}
  {Следующее окно:Next}
  {Предыдущее окно:Previous}
  {Закрыть окно:Close}
  {Список окон:WindowList}

  {главное меню информационной системы:InfoSystem}

.topic Zoom
 ─ Пункт Windows>Zoom ────────────────────

   Этот  пункт  позволяет увеличить размер
 окна  до  максимального.  Если  окно  уже
 имеет   максимальный   размер,  то  после
 выбора  этого  пункта  окно  примет  свои
 прежнии размеры.

 Комбинация клавиш: F5

 Смотри также:
  {Разместь все окна одновременно:Tile}
  {Разместь все окна каскадом:Cascade}
  {Закрыть все окна:CloseAll}
  {Изменить размер окна:Resize}
  {Следующее окно:Next}
  {Предыдущее окно:Previous}
  {Закрыть окно:Close}
  {Список окон:WindowList}

  {главное меню информационной системы:InfoSystem}

.topic Tile
 ─ Пункт Windows>Tile ────────────────────

   Этот  пункт  позволяет  разместить  все
 открытые окна по схеме показанной на этом
 рисунке:

 ┌────────────────────────────────────┐
 │ ╔════════════1══╗┌────────────2──┐ │
 │ ║               ║│               │ │
 │ ║               ║│               │ │
 │ ║               ║│               │ │
 │ ║               ║│               │ │
 │ ╚═══════════════╝└───────────────┘ │
 │ ┌────────────3──┐┌────────────4──┐ │
 │ │               ││               │ │
 │ │               ││               │ │
 │ │               ││               │ │
 │ │               ││               │ │
 │ └───────────────┘└───────────────┘ │
 └────────────────────────────────────┘

 Комбинация клавиш: нет

 Смотри также:
  {Разместь все окна каскадом:Cascade}
  {Изменить размер окна:Resize}
  {Закрыть все окна:CloseAll}
  {Увеличть/уменьшить окно:Zoom}
  {Следующее окно:Next}
  {Предыдущее окно:Previous}
  {Закрыть окно:Close}
  {Список окон:WindowList}

  {главное меню информационной системы:InfoSystem}


.topic Cascade
 ─ Пункт Windows>Cascade ─────────────────

   Этот  пункт  позволяет  разместить  все
 открытые окна по схеме показанной на этом
 рисунке:

 ┌──────────────────────────1─┐
 │┌─────────────────────────2─┐
 ││┌────────────────────────3─┐
 │││╔═══════════════════════4═╗
 │││║                         ║
 │││║                         ║
 │││║                         ║
 │││║                         ║
 │││║                         ║
 └└└╚═════════════════════════╝

 Комбинация клавиш: нет

 Смотри также:
  {Разместь все окна одновременно:Tile}
  {Изменить размер окна:Resize}
  {Закрыть все окна:CloseAll}
  {Увеличть/уменьшить окно:Zoom}
  {Следующее окно:Next}
  {Предыдущее окно:Previous}
  {Закрыть окно:Close}
  {Список окон:WindowList}

  {главное меню информационной системы:InfoSystem}


.topic CloseAll
 ─ Пункт Windows>Close All ───────────────

   Этот   пункт   позволяет   закрыть  все
 открытые окна.

 Комбинация клавиш: нет

 Смотри также:
  {Разместь все окна одновременно:Tile}
  {Разместь все окна каскадом:Cascade}
  {Изменить размер окна:Resize}
  {Увеличть/уменьшить окно:Zoom}
  {Следующее окно:Next}
  {Предыдущее окно:Previous}
  {Закрыть окно:Close}
  {Список окон:WindowList}

  {главное меню информационной системы:InfoSystem}


.topic Next
 ─ Пункт Windows>Next ────────────────────

   Этот  пункт позволяет выбрать следующее
 открытое окно.

 Комбинация клавиш: F6

 Смотри также:
  {Разместь все окна одновременно:Tile}
  {Разместь все окна каскадом:Cascade}
  {Закрыть все окна:CloseAll}
  {Изменить размер окна:Resize}
  {Увеличть/уменьшить окно:Zoom}
  {Предыдущее окно:Previous}
  {Закрыть окно:Close}
  {Список окон:WindowList}

  {главное меню информационной системы:InfoSystem}

.topic Previous
 ─ Пункт Windows>Previous ────────────────

   Этот пункт позволяет выбрать предыдущее
 окно.

 Комбинация клавиш: Shift-F6

 Смотри также:
  {Разместь все окна одновременно:Tile}
  {Разместь все окна каскадом:Cascade}
  {Закрыть все окна:CloseAll}
  {Изменить размер окна:Resize}
  {Увеличть/уменьшить окно:Zoom}
  {Следующее окно:Next}
  {Закрыть окно:Close}
  {Список окон:WindowList}

  {главное меню информационной системы:InfoSystem}


.topic Close
 ─ Пункт Windows>Close ───────────────────

   Этот   пункт  позволяет  закрыть  окно,
 которое является главным в данный момент.

 Комбинация клавиш: Alt-F3

 Смотри также:
  {Разместь все окна одновременно:Tile}
  {Разместь все окна каскадом:Cascade}
  {Закрыть все окна:CloseAll}
  {Изменить размер окна:Resize}
  {Увеличть/уменьшить окно:Zoom}
  {Следующее окно:Next}
  {Предыдущее окно:Previous}
  {Список окон:WindowList}

  {главное меню информационной системы:InfoSystem}


.topic WindowList
 ─ Пункт Windows>List... ─────────────────

   Этот  пункт  вызывает специальное окно,
 которое  содержит  список всех активных в
 данный момент окон и позволяет выбрать из
 этого  списка  окно, которое надо сделать
 главным.  Главное назначение этого пункта
 -  это  помочь  Вам  удобно  перемещаться
 между окнами.

 Комбинация клавиш: Alt-0

 Смотри также:
  {Разместь все окна одновременно:Tile}
  {Разместь все окна каскадом:Cascade}
  {Закрыть все окна:CloseAll}
  {Изменить размер окна:Resize}
  {Увеличть/уменьшить окно:Zoom}
  {Следующее окно:Next}
  {Предыдущее окно:Previous}
  {Закрыть окно:Close}

  {главное меню информационной системы:InfoSystem}












.topic MEdit
 ─ Меню Edit ─────────────────────────────

   Это  меню содержит команды для работы с
 текстом и {текстовыми блоками:TextBlock}.

 Комбинация клавиш: Alt-E

 Смотри также:
  {Отменить последнее действие:Undo}
  {Вырезать блок:Cut}
  {Копировать блок:Copy}
  {Вставить блок:Paste}
  {Удалить блок:Clear}
  {Посмотреть содержимое буффера обмена:ShowClipboard}

  {главное меню информационной системы:InfoSystem}

.topic Undo
 ─ Пункт Edit>Undo ───────────────────────

   Этот пункт позволяет отменить последние
 изменения  которые Вы зделали работая над
 текстом программы.

 Комбинация клавиш: Alt-Backspace

 Смотри также:
  {Вырезать блок:Cut}
  {Копировать блок:Copy}
  {Вставить блок:Paste}
  {Удалить блок:Clear}
  {Посмотреть содержимое буффера обмена:ShowClipboard}

  {главное меню информационной системы:InfoSystem}

.topic Cut
 ─ Пункт Edit>Cut ────────────────────────

    Этот   пункт    позволяет   скопировать
 {блок текста:TextBlock} в  {буффер обмена:TextBuffer}  для
 дальнейшего   его   использования.   Кроме
 того после того, как блок будет скопирован,
 он будет удален из текста программы.

 Комбинация клавиш: Shift-Del

 Смотри также:
  {Отменить последнее действие:Undo}
  {Копировать блок:Copy}
  {Вставить блок:Paste}
  {Удалить блок:Clear}
  {Посмотреть содержимое буффера обмена:ShowClipboard}

  {главное меню информационной системы:InfoSystem}

.topic Copy
 ─ Пункт Edit>Copy ───────────────────────

  Этот    пункт    позволяет   скопировать
 {блок текста:TextBlock} в {буффер обмена:TextBuffer} для
 дальнейшего его использования.

 Комбинация клавиш: Ctrl-Ins

 Смотри также:
  {Отменить последнее действие:Undo}
  {Вырезать блок:Cut}
  {Вставить блок:Paste}
  {Удалить блок:Clear}
  {Посмотреть содержимое буффера обмена:ShowClipboard}

  {главное меню информационной системы:InfoSystem}

.topic Paste
 ─ Пункт Edit>Paste ──────────────────────

   Этот     пункт    позволяет    вставить
 содержимое  {буффера обмена:TextBuffer} в текст.
 Вставленный {блок:TextBlock} будет начинаться  с
 места, где в данный момент находится
 {текстовый курсор:TextCursor}.

 Комбинация клавиш: Shift-Ins

 Смотри также:
  {Отменить последнее действие:Undo}
  {Вырезать блок:Cut}
  {Копировать блок:Copy}
  {Удалить блок:Clear}
  {Посмотреть содержимое буффера обмена:ShowClipboard}

  {главное меню информационной системы:InfoSystem}

.topic Clear
 ─ Пункт Edit>Clear ──────────────────────

   Этот     пункт     позволяет    удалить
 {текстовый блок:TextBlock} из текста программы.

 Комбинация клавиш: Ctrl-Del

 Смотри также:
  {Отменить последнее действие:Undo}
  {Вырезать блок:Cut}
  {Копировать блок:Copy}
  {Вставить блок:Paste}
  {Посмотреть содержимое буффера обмена:ShowClipboard}

  {главное меню информационной системы:InfoSystem}


.topic ShowClipboard
 ─ Пункт Edit>Show Clipboard ─────────────

   Этот  пункт  создает  окно и помещает в
 него содержимое {буффера обмена:TextBuffer}.

 Комбинация клавиш: нет

 Смотри также:
  {Отменить последнее действие:Undo}
  {Вырезать блок:Cut}
  {Копировать блок:Copy}
  {Вставить блок:Paste}
  {Удалить блок:Clear}

  {главное меню информационной системы:InfoSystem}











.topic MSearch
 ─ Меню Search ───────────────────────────

   Это  меню  содержит  команды для поиска
 текстовых   фрагменов   и  их  замены  на
 другие.

 Комбинация клавиш: Alt-S

 Смотри также:
  {Поиск текста:Find}
  {Замена текста:Replace}
  {Продолжение поиска:SearchAgain}

  {главное меню информационной системы:InfoSystem}

.topic Find
 ─ Пункт Search>Find... ──────────────────

   Этот  пункт позволяет отыскать в тексте
 нужный  Вам  фрагмент.  Для  этого в поле
 ввода  введите искомый фрагмент и нажмите
 клавишу   Enter.   После  этого  оболочка
 попытаеся найти нужный Вам фрагмент. Если
 поиск закончился удачно, то {текстовый курсор:TextCursor}
 перемещается   в  то место, где находится
 найденный фрагмент.

 Комбинация клавиш: F7

 Смотри также:
  {Замена текста:Replace}
  {Продолжение поиска:SearchAgain}

  {главное меню информационной системы:InfoSystem}

.topic Replace
 ─ Пункт Search>Replace... ───────────────

   Этот  пункт позволяет отыскать в тексте
 нужный  Вам  фрагмент  и  заменить его на
 новый  текст.  Для  этого  в  первом поле
 ввода  введите  искомый фрагмент, нажмите
 клавишу  Tab  или  выберите  второе  поле
 ввода с помощью мыши, введите новый текст
 и нажмите клавишу Enter.
   После  этого  оболочка  попытаеся найти
 нужный    Вам    фрагмент.   Если   поиск
 закончился  удачно, то найденный фрагмент
 заменяется на новый текст, а {текстовый курсор:TextCursor}
 перемещается   в   то  место,   где  были
 произведены изменения.

 Комбинация клавиш: нет

 Смотри также:
  {Поиск текста:Find}
  {Продолжение поиска:SearchAgain}

  {главное меню информационной системы:InfoSystem}

.topic SearchAgain
 ─ Пункт Search>Search again ─────────────

   Этот  пункт  позволяет продолжить поиск
 фрагмента  в  тексте.  Предварительно  Вы
 должны начать поиск текста.

 Комбинация клавиш: Shift-F7

 Смотри также:
  {Поиск текста:Find}
  {Замена текста:Replace}

  {главное меню информационной системы:InfoSystem}















.topic DebuggerInfo
 ─ Справочная информация ─────────────────

   Отладчик   -   это  программа,  которая
 загружает  уже  готовый исполняемый файл,
 дизассемблирует  его и начинает исполнять
 так,   как   того   хочет   пользователь.
 Использование   отладчик  помогает  найти
 ошибки    и    понять    принцип   работы
 процессора и памяти.

 Смотри также:
  {Запуск на исполнение:Run}

  {главное меню информационной системы:InfoSystem}

.topic SWPFile
 ─ Справочная информация ─────────────────

   Файл   подкачки  -  это  файл,  который
 создается эмулятором, {отладчиком:DebuggerInfo} и
 компилятором,     если      не    хватает
 оперативной памяти для каких-то действий.
 В   процессе  работы  указанных  программ
 специальный    модуль   использует   файл
 подкачки   так   как  если  бы  это  была
 оперативная      память.     Это     дает
 возможность  использовать  большие объемы
 памяти при их отсутствии.

 Смотри также:

  {главное меню информационной системы:InfoSystem}

.topic MAPFile
 ─ Справочная информация ─────────────────

   Файл  карты  памяти  - это файл который
 содержит   информацию   о   использовании
 памяти конкретной программой. Это значит,
 что этот файл содержит адреса всех меток,
 процедур   и  переменных  программы.  Эта
 информация  иногда  может понадобится для
 поиска ошибок в программе.

 Смотри также:

  {главное меню информационной системы:InfoSystem}

.topic INCFile
 ─ Справочная информация ─────────────────

   Подключаемый файл - это файл содержащий
 какую-то    часто    используемую   часть
 программы.  Если  эта часть оформляется в
 виде отдельных процедур и группируется по
 назначению,  то  такой  подключаемый файл
 можно   назвать  модулем,  который  потом
 можно  подключать  ко  всем  программам и
 использовать в них процедуры и переменные
 описанные  в подключаемом файле, как если
 бы они были описанны в программе.

 Смотри также:

  {главное меню информационной системы:InfoSystem}

.topic MainFile
 ─ Справочная информация ─────────────────

   Главным    файлом   назыввается   файл,
 который    используется    для   указания
 оболочке    что    надо    компилировать,
 запускать  и  над  чем производить другие
 действия.  Вы  можете  жестко  определить
 главный   файл,   если   выберите   пункт
 {установить  главный  файл:SetPF}  в меню {компиляция:MCompile}
 и  зададите в  нем имя  файла. Если Вы не
 определили таким образом главный файл, то
 каждый  раз,  когда оболочка будет что-то
 делать,   она   будет  брать  в  качестве
 главного  файла, имя файла, окно которого
 главное в данный момент.

 Смотри также:
  {Установить главный файл:SetPF}
  {Сбросить главный файл:ClearPF}

  {главное меню информационной системы:InfoSystem}

.topic TextBuffer
 ─ Справочная информация ─────────────────

   Буффер  обмена  -  это  область памяти,
 которая     используется    для    обмена
 небольшими   блоками   информации   между
 компонентами   программы.  Обычно  буффер
 обмена  используется  при  редактировании
 текстов  программ,  так  как в него можно
 поместить   какой-то  фрагмент  текста, а
 затем  извлеч в другом текстовом окне или
 поле ввыода, что бывает весьма удобно при
 достаточно большом объеме фрагмента.

 Смотри также:
  {Вырезать блок:Cut}
  {Копировать блок:Copy}
  {Вставить блок:Paste}
  {Удалить блок:Clear}
  {Посмотреть содержимое буффера обмена:ShowClipboard}

  {главное меню информационной системы:InfoSystem}

.topic TextBlock
 ─ Справочная информация ─────────────────

   Текстовый  блок  -  это фрагмент текста
 подсвеченый другим цветом (обычно серым).
 С  помощью текстового блока можно выделят
 любые  фрагмента  текста  и проводить над
 ними манипуляции. Для выделения текста Вы
 можете   использовать  как  мышку,  так и
 клавиатуру.  В  последнем  варианте,  для
 выделения   блока,  Вы  должны  удерживая
 клавишу Shift перемещать текстовый курсор
 в   нужном   Вам  направлении.  При  этом
 символы    будут   подсвечиваться   серым
 цветом.  По окончанию выделения Вы должны
 отпустит  клавишу  Shift. Полученый таким
 образом   текстовый   блок   может   быть
 использован  для  проведения  манипуляций
 над ним соответствующими командами.

 Смотри также:
  {Вырезать блок:Cut}
  {Копировать блок:Copy}
  {Вставить блок:Paste}
  {Удалить блок:Clear}

  {главное меню информационной системы:InfoSystem}

.topic TextCursor
 ─ Справочная информация ─────────────────

   Текстовый курсор - это мигающая чертока
 (или    прямоугольник)   в   любом   окне
 предназначенном   для  ввода  текста  или
 другой  информации  с помощью клавиатуры.
 Курсор   используется   для   визуального
 указания  положения места в тексте, где в
 данный   момент   Вы  можете  производить
 изменения.

 Смотри также:

  {главное меню информационной системы:InfoSystem}



.topic VM
 ─ Виртуальная машина ────────────────────

   Виртуалная    машина    -   это   набор
 виртуальных  устройств,  к  которым  Ваша
 программа  может  обращаться,  но которых
 может   и   не   существовать   в   вашем
 компьютере.  Это  полная независимость от
 платформы,   которая   достигается  путем
 создания виртуального процессора.
   На  данный  момент,  виртуальная машина
 позволяет   вам:  использовать  64-битное
 адресное  пространство (если у вас хватит
 места     на     диске),     обмениваться
 информацией  с  графическим  устройством,
 при    этом    вы    работаете   всегда с
 24-битной    графикой,    независимо   от
 видеоадаптера,    работать   с   файлами,
 использовать указательное устройство типа
 "мишь",   даже  в  том  случае  если  оно
 отсутствует.  В скором времени, ожидается
 потдержка  звуковых  устройств, даже если
 они   будут  отсутствовать,  и  потдержка
 сети.   Также,   вскором  времени  должны
 появиться  команды для запуска приложений
 подобных   себе,   а   также   совместное
 исполнение  сразу  нескольких  программ -
 многозадачность.
   Чтобы  Вы могли понять как это работает
 ниже    приведен   схема   взаимодействия
 программы  с  виртуальной  машиной  и  её
 отдельными     компонентами.    Стрелочки
 указывают кто с кем может общаться.

 ┌──────────────────┐    ┌───────────────┐    ┌───────────────────┐
 │ Программа, как   │    │ Ядро          │    │ Вся доступная     │
 │ алгоритм исполь- ├───│ виртуальной   │───┤ системе память, в │
 │ зования всех     │    │ машины кон-   │    │ том числе и       │
 │ компонентов для  │───┤ тролирует     ├───│ виртуальная       │
 │ достижения цели  │    │ правильность  │    │                   │
 └──────────┬───────┘    │ и легальность │    └───────┬───────────┘
                       │ доступа ко    │              
 ┌───────┴──────────┐    │ всем компо-   │    ┌──────────┴────────┐
 │ Память программы │    │ нентам        │    │ Все доступные     │
 │ - базовый компо- │───┤ виртуальной   ├───│ системе устрой-   │
 │ нент, не имеющий │    │ машины        │    │ ства, в том числе │
 │ ограничения в    ├───│               │───┤ и виртуальные     │
 │ доступе          │    │               │    │                   │
 └──────────────────┘    └───────────────┘    └───────────────────┘

   Я   принял  эту  схему  для  построения
 структуры   взаимодействия  программы  со
 всеми  компонентами виртуальной машины по
 нескольким причинам:
   ■   во-первых,  такая  схема  полностью
 блокирует   нелегальный  доступ  ко  всей
 памяти     компьютера,    что    повышает
 коэфициент безопасности системы;
   ■    во-вторых,    эта    схема    дает
 неограниченные  возможности  по изменению
 состава  компонентов,  так  как программа
 узнает о работоспособности компонентов от
 ядра.  Это  дает возможность подключить к
 ядру    модуль   эмуляции   отсутствующих
 компонентов  и  при  этом  не  пострадает
 программа,    которая    использует   эти
 компоненты;
   ■   в-третьих,  такая  схема  позволяет
 легко   адаптировать  данную  виртуальную
 машину  к  любой  проблеме, так как очень
 лекго изменить состав компонентов.

 Смотри также:

  {главное меню информационной системы:InfoSystem}

.topic RegVP
 ─ Регистры ──────────────────────────────

   Регистры  предназначены  для управления
 виртуальным   процессорм,   а  также  для
 проведения      любых     арефметических,
 логических  действий. Всего в виртуальном
 процессоре  41 регистр. Одинадцать из них
 -     8-байтные,     еще     одинадцать -
 4-байтные,  еще  одинадцать - 2-байтные и
 еще  восемь  -  1-байтные.  Некоторые  из
 этих   регистров   можно  испоьзовать  по
 своему     усмотрению,    а    некоторые,
 используются   для   работы  виртуального
 процессора.  Дальше  приводится таблица с
 именами,  размерами  и значениями каждого
 регистра.

   Регистр  общего  назначения, в основном
 используется   для   хранения  результата
 какойто математической операции, но может
 использоваться и для других целей.
 ┌─────────────────────────────────────┐
 │                 LAX                 │ - 8-байтный регистр
 ├──────────────────┬──────────────────┤
 │        EAX       │                  │ - 4-байтный регистр
 ├─────────┬────────┼──────────────────┤
 │   AX    │        │                  │ - 2-байтный регистр
 ├────┬────┼────────┼──────────────────┤
 │ AL │ AH │        │                  │ два 1-байтных регистра
 └────┴────┴────────┴──────────────────┘

 Регистр общего назначения.
 ┌─────────────────────────────────────┐
 │                 LBX                 │ - 8-байтный регистр
 ├──────────────────┬──────────────────┤
 │        EBX       │                  │ - 4-байтный регистр
 ├─────────┬────────┼──────────────────┤
 │   BX    │        │                  │ - 2-байтный регистр
 ├────┬────┼────────┼──────────────────┤
 │ BL │ BH │        │                  │ два 1-байтных регистра
 └────┴────┴────────┴──────────────────┘

   Регистр  общего  назначения, в основном
 используется  как  счетчик  в  циклах, но
 может использоваться и для других целей.
 ┌─────────────────────────────────────┐
 │                 LCX                 │ - 8-байтный регистр
 ├──────────────────┬──────────────────┤
 │        ECX       │                  │ - 4-байтный регистр
 ├─────────┬────────┼──────────────────┤
 │   CX    │        │                  │ - 2-байтный регистр
 ├────┬────┼────────┼──────────────────┤
 │ CL │ CH │        │                  │ два 1-байтных регистра
 └────┴────┴────────┴──────────────────┘

 Регистр общего назначения.
 ┌─────────────────────────────────────┐
 │                 LDX                 │ - 8-байтный регистр
 ├──────────────────┬──────────────────┤
 │        EDX       │                  │ - 4-байтный регистр
 ├─────────┬────────┼──────────────────┤
 │   DX    │        │                  │ - 2-байтный регистр
 ├────┬────┼────────┼──────────────────┤
 │ DL │ DH │        │                  │ два 1-байтных регистра
 └────┴────┴────────┴──────────────────┘

   Регистр   начала   стека,  указвает  на
 начало  стека в памяти, при его изменении
 можно  добиться такого расположения стека
 в памяти, как надо программисту.
 ┌─────────────────────────────────────┐
 │                 LSS                 │ - 8-байтный регистр
 ├──────────────────┬──────────────────┤
 │        ESS       │                  │ - 4-байтный регистр
 ├─────────┬────────┼──────────────────┤
 │   SS    │        │                  │ - 2-байтный регистр
 └─────────┴────────┴──────────────────┘

   Стековый указатель, указывает на голову
 стека  относительно  начала  стека,  если
 равен нулю, то стек пуст.
 ┌─────────────────────────────────────┐
 │                 LSP                 │ - 8-байтный регистр
 ├──────────────────┬──────────────────┤
 │        ESP       │                  │ - 4-байтный регистр
 ├─────────┬────────┼──────────────────┤
 │   SP    │        │                  │ - 2-байтный регистр
 └─────────┴────────┴──────────────────┘

   Командный указатель, указывает на адрес
 следующей    команды,    которую    будет
 исполнять   виртуальный   процессор,  при
 изменении  значения  этого регистра можно
 изменить   последовательность  выполнения
 команд.
 ┌─────────────────────────────────────┐
 │                 LIP                 │ - 8-байтный регистр
 ├──────────────────┬──────────────────┤
 │        EIP       │                  │ - 4-байтный регистр
 ├─────────┬────────┼──────────────────┤
 │   IP    │        │                  │ - 2-байтный регистр
 └─────────┴────────┴──────────────────┘

   Дополнительный     указатель,    обычно
 используется как адрес источника какой-то
 информации, но может использоваться и для
 других целей.
 ┌─────────────────────────────────────┐
 │                 LEP                 │ - 8-байтный регистр
 ├──────────────────┬──────────────────┤
 │        EEP       │                  │ - 4-байтный регистр
 ├─────────┬────────┼──────────────────┤
 │   EP    │        │                  │ - 2-байтный регистр
 └─────────┴────────┴──────────────────┘

   Дополнительный     указатель,    обычно
 используется    как    адрес   назначения
 какой-то     информации,     но     может
 использоваться и для других целей.
 ┌─────────────────────────────────────┐
 │                 LFP                 │ - 8-байтный регистр
 ├──────────────────┬──────────────────┤
 │        EFP       │                  │ - 4-байтный регистр
 ├─────────┬────────┼──────────────────┤
 │   FP    │        │                  │ - 2-байтный регистр
 └─────────┴────────┴──────────────────┘

 Дополнительный указатель.
 ┌─────────────────────────────────────┐
 │                 LGP                 │ - 8-байтный регистр
 ├──────────────────┬──────────────────┤
 │        EGP       │                  │ - 4-байтный регистр
 ├─────────┬────────┼──────────────────┤
 │   GP    │        │                  │ - 2-байтный регистр
 └─────────┴────────┴──────────────────┘

   Регистр  состояния флагов, содержит все
 флаги      процессора,      но      может
 использоваться   и  для  других  целей, с
 учетом     последующего    востановления,
 правда при этом могут возникнуть проблемы
 с    условным   переходом.   Введен   для
 облегчения работы с флагами.
 ┌─────────────────────────────────────┐
 │                 LFS                 │ - 8-байтный регистр
 ├──────────────────┬──────────────────┤
 │        EFS       │                  │ - 4-байтный регистр
 ├─────────┬────────┼──────────────────┤
 │   FS    │        │                  │ - 2-байтный регистр
 └─────────┴────────┴──────────────────┘

 ─ Флаги ─────────────────────────────────

   Флаги    предназначены   для   указания
 программе   на   какое-то  изменение  или
 ошибку     при     работе    виртуального
 процессора.   Дальше   приведена  таблица
 флагов и их назначение.

   ■  Флаг  O - флаг переполнения. Равен 1
 если    в    результате    математической
 операции получилось значение выходящие за
 пределы   источника,   во   всех   других
 случаях равен 0.

   ■  Флаг  S - флаг знака. Равен 1 если в
 результате     математической    операции
 получилось  отрицательное  число, во всех
 других случаях равен 1.

   ■  Флаг  Z  - флаг нуля. Равен 1 если в
 результате     математической    операции
 получили 0, во всех других случаях равен 0.

   ■  Флаг P - флаг четности. Равен 1 если
 в   результате   математической  операции
 получили  четное  число,  во  всех других
 случаях равен 0.

   ■  Флаг C - флаг переноса. Равен 1 если
 в   результате   математической  операции
 произошел переход разряда, во всех других
 случаях равен 0.

   ■  Флаг  A - дополнительный флаг. Может
 использоваться  программистом  по  своему
 усмотрению.

 Смотри также:

  {главное меню информационной системы:InfoSystem}

.topic MandS
 ─ Память и стек ─────────────────────────

   Любая  программа  написанная  для  моей
 виртуальной     машины    располагается в
 памяти  следующим образом. Память делится
 на  три  блока:  блок  кода, блок данных,
 блок  стека и свободной памяти. Блок кода
 имеет  размер  кода, блок данных - даных,
 блок  стека  -  сколько  вы  укажете  при
 написании  программы.  Блок  кода  всегда
 начинается   с   нулевого   адреса.  Блок
 данных,  всегда  начинается  сразу  после
 блока  кода,  так,  что между этими двумя
 блоками       отсутствует      промежуток
 неиспользуемой  памяти,  а  блок  стека и
 свободной  памяти  начинается сразу после
 блока  данных. Адрес начала блока стека и
 свободной  памяти  содержится  в регистре
 LSS.  Зная  это  вы  можете при написании
 программы заведомо выделить больше памяти
 под  стека  чем требует ваша программа, а
 затем  при  запуске  программы, вы можете
 изменить  размер  стека,  переместив  его
 начало   ближе  к  концу  всей  доступной
 программе   памяти.   Таким   образом  вы
 освободите   себе   требуемое  количество
 памяти сразу после блока данных и сможете
 использовать её по своему усмотрению. Все
 что здесь написанно ниже пояснено на двух
 схемах.  Стрелочки показывают направление
 роста стека.

   Вид   памяти   сразу   после   загрузки
 программы на исполнение:

   ╔═══════════╗ - 0                                ─┐
   ║ Блок кода ║                                     │
   ║ программы ║                                     │
   ╟───────────╢ - Размер кода                       │
   ║   Блок    ║                                     │
   ║  данных   ║                                     │   Вся доступная
   ║ программы ║                                     ├─ программе память
   ╟───────────╢ - Размер кода + размер данных = LSS │
 │ ║   Блок    ║   Начало стека                      │
 │ ║  стека и  ║                                     │
 │ ║ свободной ║   Используется только под стек      │
 │ ║  памяти   ║                                     │
  ║ программы ║                                     │
   ╚═══════════╝                                    ─┘

   Способ освобождения дополнительной памяти:
   ╔═══════════╗ - 0                                ─┐
   ║ Блок кода ║                                     │
   ║ программы ║                                     │
   ╟───────────╢ - Размер кода                       │
   ║   Блок    ║                                     │
   ║  данных   ║                                     │
   ║ программы ║                                     │   Вся доступная
   ╟───────────╢ - Размер кода + размер данных       ├─ программе память
   ║           ║                                     │
   ║ Свободная ║   Используете как хотите            │
   ║  память   ║                                     │
   ║           ║                                     │
 │ ╟─ ─ ─ ─ ─ ─╢ - LSS                               │
 │ ║   Блок    ║   Начало стека                      │
  ║  стека    ║   Используется только под стек      │
   ╚═══════════╝                                    ─┘

 Смотри также:

  {главное меню информационной системы:InfoSystem}

.topic ComVP
 ─ Команды виртуального процессора ───────

   Все   команды  виртуального  процессора
 можно  разделить  на  пять типов:
  {команды перемещения информации:MovCom},
  {арифметические команды:MatCom},
  {логические команды:LogCom},
  {команды управления потоком:StreamCom} и
  {команды управления виртуальным процессором:VPCom}.
   Если  Вы  хотите  ознакомиться  с  ними
 болле  детально выберите тот тип, который
 Вас интерисует.

 Смотри также:

  {главное меню информационной системы:InfoSystem}

.topic MovCom
 ─ Команды перемещения информации ────────

   Команды      перемещения     информации
 предназначены   для   изменения  значений
 хранящихся    по    каким-то    адресам и
 дальнейшем  их  использовании. Далее идет
 список  всех  команд,  выбрав  нужную Вам
 перейдите  на  страницу содержащюю помощь
 по этой команде.

 Смотри также:
  {MOV}
  {PUSH}
  {POP}
  {XCHG}

  {главное меню информационной системы:InfoSystem}

.topic MOV
 ─ Команды перемещения информации ────────

 MOV назначение, источник
 ─────────────────────────────────────────
   Эта  команда  является одной из главных
 команд,  т.к.  она  позволяет  перемещать
 данный   между   памятью   и  регистрами.
 Вкачестве   параметров   команда   должна
 получать   два   параметра:  назначение и
 источник.  Назначение  - это то куда надо
 переместить информацию. Источник - это то
 откуда  надо  переместить  информацию или
 что  переместить.  В  качестве назначения
 допускается    использовать    один    из
 регистров или адрес в памяти.
   Если    вы   используете   в   качестве
 назначения  -  регистр, то в этот регистр
 будет помещенно соответствующее значение.
 Если    вы    используете    в   качестве
 назначения   -   адрес   в   памяти,   то
 соответствующее  значение по этому адресу
 будет изменено.
   При  формировании  адреса  в  памяти вы
 можете     задать     его     несколькими
 спосабами.  Первый способ - вы указываете
 имя  переменной  или сразу число, незабыв
 при  этом  взять его в квадратные скобки,
 т.к.   вы  хотите  задать  адрес.  Второй
 способ  - вы указываете регистр, при этом
 при   пересылке  данных,  значение  этого
 регистра будет рассматриваться как адрес,
 незабутьте  взять  регистр  в  квадратные
 скобки,  т.к.  вы  хотите  задать  адрес.
 Третий   способ   -   это  один  из  двух
 предыдущих  способов,  плюс то, что перед
 закрывающей  квадратной скобкой вы можете
 поставить  регистр через знак плюс, тогда
 при  выполнении,  значение этого регистра
 будет   прибавленно  к  адресу  заданному
 одним из предыдущих способов.
   В    качестве   источника   допускается
 использовать  регистр,  число или адрес в
 памяти.  Если  вы  используете в качестве
 источника   -  регистр,  то  перемещаемое
 значение будет браться из этого регистра.
 Если  вы используете в качестве источника
 -   число,   то  перемещаться  будет  это
 число.  Если  вы  используете  в качестве
 источника  -  адрес в памяти, то значение
 находящееся   по   этому   адресу   будет
 перемещаемым.   При  задании  адреса,  вы
 можете  пользоваться  советом  по заданию
 адреса для назначения.
   Источник  и  назначение  не  могут быть
 одновременно   адресами  в  памяти,  т.е.
 пересылка  иноформации из памяти в память
 не возможна.
   Для     точного     определения    типа
 перемещаемой информации после команды MOV
 Вы  должны  поставить  слово: word, WORD,
 DWORD,  QWORD  -  один  байт, два байта -
 слово,  четыри  байта  -  двойное  слово,
 восемь    байт    -    четверно   слово -
 соответственно, по умолчанию перемещается
 один байт. При работе с обоими регистрами
 этого можно не делать.
   Эта  команды ни каким образом не влияет
 на флаги виртуального процессора.

 Пример использования команды MOV:
  mov ax, bx          ; bx --> ax
  mov ax, [bx]        ; byte [bx] --> ax
  mov ax, [bx+cx]     ; byte [bx+cx] --> ax
  mov ax, 1           ; 1 --> ax
  mov ax, [1]         ; byte [1] --> ax
  mov ax, [1+bx]      ; byte [1+bx] --> ax
  mov [ax], bx        ; bx --> byte [ax]
  mov [ax], 1         ; 1 --> byte [ax]
  mov [ax+cx], bx     ; bx --> byte [ax+cx]
  mov [ax+cx], 1      ; 1 --> byte [ax+cx]
  mov [1], ax         ; ax --> byte [1]
  mov [1], 1          ; 1 --> byte [1]
  mov [1+ax], bx      ; bx --> byte [1+ax]
  mov [1+ax], 1       ; 1 --> byte [1+ax]
  mov word ax, bx      ; bx --> ax
  mov word ax, [bx]    ; word [bx] --> ax
  mov word ax, [bx+cx] ; word [bx+cx] --> ax
  mov word ax, 1       ; 1 --> ax
  mov word ax, [1]     ; word [1] --> ax
  mov word ax, [1+bx]  ; word [1+bx] --> ax
  mov word [ax], bx    ; bx --> word [ax]
  mov word [ax], 1     ; 1 --> word [ax]
  mov word [ax+cx], bx ; bx --> word [ax+cx]
  mov word [ax+cx], 1  ; 1 --> word [ax+cx]
  mov word [1], ax     ; ax --> word  [1]
  mov word [1], 1      ; 1 --> word [1]
  mov word [1+ax], bx  ; bx --> word [1+ax]
  mov word [1+ax], 1   ; 1 --> word [1+ax]

 Смотри также:
  {Команды перемещения информации:MovCom}
  {PUSH}
  {POP}
  {XCHG}

  {главное меню информационной системы:InfoSystem}

.topic PUSH
 ─ Команды перемещения информации ────────

 PUSH источник
 ─────────────────────────────────────────
   Эта  команда  позволяет вам поместить в
 стек  любое  число.  Она имеет всего один
 параметр   -  источник  -  то,  что  надо
 помещать  в  стек.  В  качестве источника
 может  выступать регистр, адрес в памяти,
 число.
   Если  в  качестве  источника  выступает
 адрес  в  памяти, вы должны указать явным
 образом сколько байт находящихся по этому
 адресу  вы  хотите  поместить в стек. Для
 этого,   вы  должны  после  команды  PUSH
 использовать  те  же слова, что в команде
 MOV  для  явного определения типа. Если в
 качестве  источника выступает регистр или
 число, этого можно не делать.
   Эта  команды ни каким образом не влияет
 на флаги виртуального процессора.

 Пример использования команды PUSH:
  push ax           ; ax --> stack
  push 1            ; 1 --> stack
  push [ax]         ; byte [ax] --> stack
  push [ax+cx]      ; byte [ax+cx] --> stack
  push [1]          ; byte [1] --> stack
  push [1+cx]       ; byte [1+cx] --> stack
  push word [ax]    ; word [ax] --> stack
  push word [ax+cx] ; word [ax+cx] --> stack
  push word [1]     ; word [1] --> stack
  push word [1+cx]  ; word [1+cx] --> stack

 Смотри также:
  {Команды перемещения информации:MovCom}
  {MOV}
  {POP}
  {XCHG}

  {главное меню информационной системы:InfoSystem}

.topic POP
 ─ Команды перемещения информации ────────

 POP назначение
 ─────────────────────────────────────────
   Эта  команда  позволяет  вам извлечь из
 стек  любое  число.  Она имеет всего один
 параметр  -  назначение  -  то, куда надо
 поместить  извлеченное  число. В качестве
 назанчения  может  выступать  регистр или
 адрес в памяти.
   Если  в  качестве  назначения выступает
 адрес  в  памяти, вы должны указать явным
 образом    сколько    байт    разрешается
 использовать     по     этому    адресу и
 соответственно  сколько байт извлекать из
 стека. Для этого, вы должны после команды
 POP   исопльзовать  те  же  слова,  что в
 команде  MOV для явного определения типа.
 Если   в   качестве  источника  выступает
 регистр, этого можно не делать.
   Эта  команды ни каким образом не влияет
 на флаги виртуального процессора.

 Пример использования команды POP:
  pop ax           ; stack --> ax
  pop [ax]         ; stack --> byte [ax]
  pop [ax+cx]      ; stack --> byte [ax+cx]
  pop [1]          ; stack --> byte [1]
  pop [1+cx]       ; stack --> byte [1+cx]
  pop word [ax]    ; stack --> word [ax]
  pop word [ax+cx] ; stack --> word [ax+cx]
  pop word [1]     ; stack --> word [1]
  pop word [1+cx]  ; stack --> word [1+cx]

 Смотри также:
  {Команды перемещения информации:MovCom}
  {MOV}
  {PUSH}
  {XCHG}

  {главное меню информационной системы:InfoSystem}

.topic XCHG
 ─ Команды перемещения информации ────────

 XCHG источник, назначение
 ─────────────────────────────────────────
   Эта команда позволяет обменять значение
 источника  на  значение  назначения, т.е.
 меняет  их  значения  местами. В качестве
 источника  и  назначения  может выступать
 регистр или адрес в памяти.
   Источник  и  назначение  не  могут быть
 одновременно   адресами  в  памяти,  т.е.
 обмен значений не может происходить между
 значениями в памяти.
   Если   в   качестве   источника   или в
 качестве   назначения  выступает  адрес в
 памяти,   то   вы  должны  явным  образом
 указать,  сколько  байт  по  этому адресу
 относятся  к  значению.  Для  этого сразу
 после    команды    XCHG,    вы    должны
 использовать  одно  из  слов  описанных в
 команде  MOV. Если в качестве источника и
 назначения  выступают  регистры, то этого
 можно не делать.
   Эта  команды ни каким образом не влияет
 на флаги виртуального процессора.

 Пример использования команды XCHG:
  xchg ax, bx           ; ax <--> bx
  xchg ax, [bx]         ; ax <--> byte [bx]
  xchg ax, [bx+cx]      ; ax <--> byte [bx+cx]
  xchg ax, [1]          ; ax <--> byte [1]
  xchg ax, [1+cx]       ; ax <--> byte [1+cx]
  xchg [ax], bx         ; byte [ax] <--> bx
  xchg [ax+cx], bx      ; byte [ax+cx] <--> bx
  xchg [1], ax          ; byte [1] <--> ax
  xchg [1+cx], ax       ; byte [1+cx] <--> ax
  xchg word ax, [bx]    ; ax <--> word [bx]
  xchg word ax, [bx+cx] ; ax <--> word [bx+cx]
  xchg word ax, [1]     ; ax <--> word [1]
  xchg word ax, [1+cx]  ; ax <--> word [1+cx]
  xchg word [ax], bx    ; word [ax] <--> bx
  xchg word [ax+cx], bx ; word [ax+cx] <--> bx
  xchg word [1], ax     ; word [1] <--> ax
  xchg word [1+cx], ax  ; word [1+cx] <--> ax

 Смотри также:
  {Команды перемещения информации:MovCom}
  {MOV}
  {PUSH}
  {POP}

  {главное меню информационной системы:InfoSystem}

.topic MatCom
 ─ Арифметические команды ────────────────

   Арефметические   команды  предназначены
 для   проведения  простых  арефметических
 действий   над   значения   хранящимися в
 регистрах или в памяти. Далее идет список
 всех арефметических команд, выбрав нужную
 Вам   перейдите  на  страницу  содержащюю
 помощь по этой команде.

 Смотри также:
  {ADD}        {SUB}
  {MUL}        {DIV}
  {INC}        {DEC}
  {NEG}        {CMP}

  {главное меню информационной системы:InfoSystem}

.topic ADD
 ─ Арифметические команды ────────────────

 ADD назначение, источник
 ─────────────────────────────────────────
   Эта  команда  выполняет  сложение  двух
 значений     и    результат    помещает в
 назначение.  Значение  певого  слагаемого
 берется   из  назначения,  второго  -  из
 источника.
   В  качестве  источника  могут выступать
 регисры,  числа  и значение в памяти. А в
 качестве   назначения  только  регистры и
 значение   в   памяти.  Если  в  качестве
 источника   или  назначения  используется
 значение  в  памяти  -  Вы должны указать
 явным    образом    тип   информации   по
 указанному адресу (см. {MOV})
   При использования этой команды значение
 источника не меняется.
   Результат    операции   анализируется и
 согласно правилам (см. {Регистры и флаги:RegVP})
 изменяются значения нужных флагов.

 Пример использования команды add:
  add ax, bx          ; ax = ax + bx
  add ax, [bx]        ; ax = ax + byte [bx]
  add ax, [bx+cx]     ; ax = ax + byte [bx+cx]
  add ax, 1           ; ax = ax + 1
  add ax, [1]         ; ax = ax + byte [1]
  add ax, [1+bx]      ; ax = ax + byte [1+bx]
  add [ax], bx        ; byte [ax] = byte [ax] + bx
  add [ax], 1         ; byte [ax] = byte [ax] + 1
  add [ax+cx], bx     ; byte [ax+cx] = byte [ax+cx] + bx
  add [ax+cx], 1      ; byte [ax+cx] = byte [ax+cx] + 1
  add [1], ax         ; byte [1] = byte [1] + ax
  add [1], 1          ; byte [1] = byte [1] + 1
  add [1+ax], bx      ; byte [1+ax] = byte [1+ax] + bx
  add [1+ax], 1       ; byte [1+ax] = byte [1+ax] + 1
  add word ax, bx      ; ax = ax + bx
  add word ax, [bx]    ; ax = ax + word [bx]
  add word ax, [bx+cx] ; ax = ax + word [bx+cx]
  add word ax, 1       ; ax = ax + 1
  add word ax, [1]     ; ax = ax + word [1]
  add word ax, [1+bx]  ; ax = ax + word [1+bx]
  add word [ax], bx    ; word [ax] = word [ax] + bx
  add word [ax], 1     ; word [ax] = word [ax] + 1
  add word [ax+cx], bx ; word [ax+cx] = word [ax+cx] + bx
  add word [ax+cx], 1  ; word [ax+cx] = word [ax+cx] + 1
  add word [1], ax     ; word [1] = word [1] + ax
  add word [1], 1      ; word [1] = word [1] + 1
  add word [1+ax], bx  ; word [1+ax] = word [1+ax] + bx
  add word [1+ax], 1   ; word [1+ax] = word [1+ax] + 1

 Смотри также:
  {Арифметические команды:MatCom}
  {SUB}        {MUL}
  {DIV}        {INC}
  {DEC}        {NEG}
  {CMP}

  {главное меню информационной системы:InfoSystem}

.topic SUB
 ─ Арифметические команды ────────────────

 SUB назначение, источник
 ─────────────────────────────────────────
   Эта  команда  выполняет  вычитание двух
 значений     и     разность    помещает в
 назначение. Значение уменьшаемого берется
 из  назначения, значение вычитаемого - из
 источника.
   В  качестве  источника  могут выступать
 регисры,  числа  и значение в памяти. А в
 качестве   назначения  только  регистры и
 значение   в   памяти.  Если  в  качестве
 источника   или  назначения  используется
 значение  в  памяти  -  Вы должны указать
 явным    образом    тип   информации   по
 указанному адресу (см. {MOV})
   При использования этой команды значение
 источника не меняется. Результат операции
 анализируется  и  согласно  правилам (см.
 {Регистры и флаги:RegVP}) изменяются значения
 нужных флагов.

 Пример использования команды sub:
  sub ax, bx          ; ax = ax - bx
  sub ax, [bx]        ; ax = ax - byte [bx]
  sub ax, [bx+cx]     ; ax = ax - byte [bx+cx]
  sub ax, 1           ; ax = ax - 1
  sub ax, [1]         ; ax = ax - byte [1]
  sub ax, [1+bx]      ; ax = ax - byte [1+bx]
  sub [ax], bx        ; byte [ax] = byte [ax] - bx
  sub [ax], 1         ; byte [ax] = byte [ax] - 1
  sub [ax+cx], bx     ; byte [ax+cx] = byte [ax+cx] - bx
  sub [ax+cx], 1      ; byte [ax+cx] = byte [ax+cx] - 1
  sub [1], ax         ; byte [1] = byte [1] - ax
  sub [1], 1          ; byte [1] = byte [1] - 1
  sub [1+ax], bx      ; byte [1+ax] = byte [1+ax] - bx
  sub [1+ax], 1       ; byte [1+ax] = byte [1+ax] - 1
  sub word ax, bx      ; ax = ax - bx
  sub word ax, [bx]    ; ax = ax - word [bx]
  sub word ax, [bx+cx] ; ax = ax - word [bx+cx]
  sub word ax, 1       ; ax = ax - 1
  sub word ax, [1]     ; ax = ax - word [1]
  sub word ax, [1+bx]  ; ax = ax - word [1+bx]
  sub word [ax], bx    ; word [ax] = word [ax] - bx
  sub word [ax], 1     ; word [ax] = word [ax] - 1
  sub word [ax+cx], bx ; word [ax+cx] = word [ax+cx] - bx
  sub word [ax+cx], 1  ; word [ax+cx] = word [ax+cx] - 1
  sub word [1], ax     ; word [1] = word [1] - ax
  sub word [1], 1      ; word [1] = word [1] - 1
  sub word [1+ax], bx  ; word [1+ax] = word [1+ax] - bx
  sub word [1+ax], 1   ; word [1+ax] = word [1+ax] - 1

 Смотри также:
  {Арифметические команды:MatCom}
  {ADD}        {MUL}
  {DIV}        {INC}
  {DEC}        {NEG}
  {CMP}

  {главное меню информационной системы:InfoSystem}

.topic MUL
 ─ Арифметические команды ────────────────

 MUL назначение, источник
 ─────────────────────────────────────────
   Эта  команда  выполняет  умножение двух
 значений    и   произведение   помещает в
 назначение.  Значение  первого  множителя
 берется   из  назначения,  второго  -  из
 источника.
   В  качестве  источника  могут выступать
 регисры,  числа  и значение в памяти. А в
 качестве   назначения  только  регистры и
 значение   в   памяти.  Если  в  качестве
 источника   или  назначения  используется
 значение  в  памяти  -  Вы должны указать
 явным    образом    тип   информации   по
 указанному адресу (см. {MOV})
   При использования этой команды значение
 источника не меняется. Результат операции
 анализируется  и  согласно  правилам (см.
 {Регистры и флаги:RegVP})  изменяются  значения
 нужных флагов.

 Пример использования команды mul:
  mul ax, bx          ; ax = ax * bx
  mul ax, [bx]        ; ax = ax * byte [bx]
  mul ax, [bx+cx]     ; ax = ax * byte [bx+cx]
  mul ax, 1           ; ax = ax * 1
  mul ax, [1]         ; ax = ax * byte [1]
  mul ax, [1+bx]      ; ax = ax * byte [1+bx]
  mul [ax], bx        ; byte [ax] = byte [ax] * bx
  mul [ax], 1         ; byte [ax] = byte [ax] * 1
  mul [ax+cx], bx     ; byte [ax+cx] = byte [ax+cx] * bx
  mul [ax+cx], 1      ; byte [ax+cx] = byte [ax+cx] * 1
  mul [1], ax         ; byte [1] = byte [1] * ax
  mul [1], 1          ; byte [1] = byte [1] * 1
  mul [1+ax], bx      ; byte [1+ax] = byte [1+ax] * bx
  mul [1+ax], 1       ; byte [1+ax] = byte [1+ax] * 1
  mul word ax, bx      ; ax = ax * bx
  mul word ax, [bx]    ; ax = ax * word [bx]
  mul word ax, [bx+cx] ; ax = ax * word [bx+cx]
  mul word ax, 1       ; ax = ax * 1
  mul word ax, [1]     ; ax = ax * word [1]
  mul word ax, [1+bx]  ; ax = ax * word [1+bx]
  mul word [ax], bx    ; word [ax] = word [ax] * bx
  mul word [ax], 1     ; word [ax] = word [ax] * 1
  mul word [ax+cx], bx ; word [ax+cx] = word [ax+cx] * bx
  mul word [ax+cx], 1  ; word [ax+cx] = word [ax+cx] * 1
  mul word [1], ax     ; word [1] = word [1] * ax
  mul word [1], 1      ; word [1] = word [1] * 1
  mul word [1+ax], bx  ; word [1+ax] = word [1+ax] * bx
  mul word [1+ax], 1   ; word [1+ax] = word [1+ax] * 1

 Смотри также:
  {Арифметические команды:MatCom}
  {ADD}        {SUB}
  {DIV}        {INC}
  {DEC}        {NEG}
  {CMP}

  {главное меню информационной системы:InfoSystem}

.topic DIV
 ─ Арифметические команды ────────────────

 DIV назначение, источник
 ─────────────────────────────────────────
   Эта   команда  выполняет  деление  двух
 значений      и     часное     помещает в
 назначение.  Значение делимого берется из
 назначения,   значение   делителя   -  из
 источника.
   В  качестве  источника  могут выступать
 регисры,  числа  и значение в памяти. А в
 качестве   назначения  только  регистры и
 значение   в   памяти.  Если  в  качестве
 источника   или  назначения  используется
 значение  в  памяти  -  Вы должны указать
 явным    образом    тип   информации   по
 указанному адресу (см. {MOV})
   При использования этой команды значение
 источника не меняется.
   Результат    операции   анализируется и
 согласно правилам  (см. {Регистры и флаги:RegVP})
 изменяются значения нужных флагов.

 Пример использования команды div:
  div ax, bx          ; ax = ax / bx
  div ax, [bx]        ; ax = ax / byte [bx]
  div ax, [bx+cx]     ; ax = ax / byte [bx+cx]
  div ax, 1           ; ax = ax / 1
  div ax, [1]         ; ax = ax / byte [1]
  div ax, [1+bx]      ; ax = ax / byte [1+bx]
  div [ax], bx        ; byte [ax] = byte [ax] / bx
  div [ax], 1         ; byte [ax] = byte [ax] / 1
  div [ax+cx], bx     ; byte [ax+cx] = byte [ax+cx] / bx
  div [ax+cx], 1      ; byte [ax+cx] = byte [ax+cx] / 1
  div [1], ax         ; byte [1] = byte [1] / ax
  div [1], 1          ; byte [1] = byte [1] / 1
  div [1+ax], bx      ; byte [1+ax] = byte [1+ax] / bx
  div [1+ax], 1       ; byte [1+ax] = byte [1+ax] / 1
  div word ax, bx      ; ax = ax / bx
  div word ax, [bx]    ; ax = ax / word [bx]
  div word ax, [bx+cx] ; ax = ax / word [bx+cx]
  div word ax, 1       ; ax = ax / 1
  div word ax, [1]     ; ax = ax / word [1]
  div word ax, [1+bx]  ; ax = ax / word [1+bx]
  div word [ax], bx    ; word [ax] = word [ax] / bx
  div word [ax], 1     ; word [ax] = word [ax] / 1
  div word [ax+cx], bx ; word [ax+cx] = word [ax+cx] / bx
  div word [ax+cx], 1  ; word [ax+cx] = word [ax+cx] / 1
  div word [1], ax     ; word [1] = word [1] / ax
  div word [1], 1      ; word [1] = word [1] / 1
  div word [1+ax], bx  ; word [1+ax] = word [1+ax] / bx
  div word [1+ax], 1   ; word [1+ax] = word [1+ax] / 1

 Смотри также:
  {Арифметические команды:MatCom}
  {ADD}        {SUB}
  {MUL}        {INC}
  {DEC}        {NEG}
  {CMP}

  {главное меню информационной системы:InfoSystem}

.topic INC
 ─ Арифметические команды ────────────────

 INC назначение
 ─────────────────────────────────────────
   Эта    команда   выполняет   увеличение
 назначения на 1.
   В  качестве  назначения могут выступать
 только регистры и значение в памяти. Если
 в    качестве   назначения   используется
 значение  в  памяти  -  Вы должны указать
 явным    образом    тип   информации   по
 указанному адресу (см. {MOV})
   Результат    операции   анализируется и
 согласно правилам  (см. {Регистры и флаги:RegVP})
 изменяются значения нужных флагов.

 Пример использования команды inc:
  inc ax           ; ax = ax + 1
  inc [ax]         ; byte [ax] = byte [ax] + 1
  inc [ax+bx]      ; byte [ax+bx] = byte [ax+bx] + 1
  inc [1]          ; byte [1] = byte [1] + 1
  inc [1+ax]       ; byte [1+ax] = byte [1+ax] + 1
  inc word [ax]    ; word [ax] = word [ax] + 1
  inc word [ax+bx] ; word [ax+bx] = word [ax+bx] + 1
  inc word [1]     ; word [1] = word [1] + 1
  inc word [1+ax]  ; word [1+ax] = word [1+ax] + 1

 Смотри также:
  {Арифметические команды:MatCom}
  {ADD}        {SUB}
  {MUL}        {DIV}
  {DEC}        {NEG}
  {CMP}

  {главное меню информационной системы:InfoSystem}

.topic DEC
 ─ Арифметические команды ────────────────

 DEC назначение
 ─────────────────────────────────────────
   Эта    команда   выполняет   уменьшение
 назначения на 1.
   В  качестве  назначения могут выступать
 только регистры и значение в памяти. Если
 в    качестве   назначения   используется
 значение  в  памяти  -  Вы должны указать
 явным    образом    тип   информации   по
 указанному адресу (см. {MOV})
   Результат    операции   анализируется и
 согласно правилам  (см. {Регистры и флаги:RegVP})
 изменяются значения нужных флагов.

 Пример использования команды dec:
  dec ax           ; ax = ax - 1
  dec [ax]         ; byte [ax] = byte [ax] - 1
  dec [ax+bx]      ; byte [ax+bx] = byte [ax+bx] - 1
  dec [1]          ; byte [1] = byte [1] - 1
  dec [1+ax]       ; byte [1+ax] = byte [1+ax] - 1
  dec word [ax]    ; word [ax] = word [ax] - 1
  dec word [ax+bx] ; word [ax+bx] = word [ax+bx] - 1
  dec word [1]     ; word [1] = word [1] - 1
  dec word [1+ax]  ; word [1+ax] = word [1+ax] - 1

 Смотри также:
  {Арифметические команды:MatCom}
  {ADD}        {SUB}
  {MUL}        {DIV}
  {INC}        {NEG}
  {CMP}

  {главное меню информационной системы:InfoSystem}

.topic NEG
 ─ Арифметические команды ────────────────

 NEG назначение
 ─────────────────────────────────────────
   Эта  команда  меняет знак назначения на
 противоположный.
   В  качестве  назначения могут выступать
 только регистры и значение в памяти. Если
 в    качестве   назначения   используется
 значение  в  памяти  -  Вы должны указать
 явным    образом    тип   информации   по
 указанному адресу (см. {MOV})
   Результат    операции   анализируется и
 согласно правилам  (см. {Регистры и флаги:RegVP})
 изменяются значения нужных флагов.

 Пример использования команды neg:
  neg ax           ; ax = - ax
  neg [ax]         ; byte [ax] = - byte [ax]
  neg [ax+bx]      ; byte [ax+bx] = - byte [ax+bx]
  neg [1]          ; byte [1] = - byte [1]
  neg [1+ax]       ; byte [1+ax] = - byte [1+ax]
  neg word [ax]    ; word [ax] = - word [ax]
  neg word [ax+bx] ; word [ax+bx] = - word [ax+bx]
  neg word [1]     ; word [1] = - word [1]
  neg word [1+ax]  ; word [1+ax] = - word [1+ax]

 Смотри также:
  {Арифметические команды:MatCom}
  {ADD}        {SUB}
  {MUL}        {DIV}
  {INC}        {DEC}
  {CMP}

  {главное меню информационной системы:InfoSystem}

.topic CMP
 ─ Арифметические команды ────────────────

 CMP назначение, источник
 ─────────────────────────────────────────
   Эта  команда  выполняет  вычитание двух
 значений,    но    разность   никуда   не
 помещает,  а  использует  для модификации
 флагов.
   Значение    уменьшаемого   берется   из
 назначения,  значение  вычитаемого  -  из
 источника.
   В  качестве  источника  могут выступать
 регисры,  числа  и значение в памяти. А в
 качестве   назначения  только  регистры и
 значение   в   памяти.  Если  в  качестве
 источника   или  назначения  используется
 значение  в  памяти  -  Вы должны указать
 явным    образом    тип   информации   по
 указанному адресу (см. {MOV})
   При использования этой команды значение
 источника и назначения не меняется.
   Результат    операции   анализируется и
 согласно правилам  (см. {Регистры и флаги:RegVP})
 изменяются значения нужных флагов.

 Пример использования команды cmp:
  cmp ax, bx          ; ax - bx
  cmp ax, [bx]        ; ax - byte [bx]
  cmp ax, [bx+cx]     ; ax - byte [bx+cx]
  cmp ax, 1           ; ax - 1
  cmp ax, [1]         ; ax - byte [1]
  cmp ax, [1+bx]      ; ax - byte [1+bx]
  cmp [ax], bx        ; byte [ax] - bx
  cmp [ax], 1         ; byte [ax] - 1
  cmp [ax+cx], bx     ; byte [ax+cx] - bx
  cmp [ax+cx], 1      ; byte [ax+cx] - 1
  cmp [1], ax         ; byte [1] - ax
  cmp [1], 1          ; byte [1] - 1
  cmp [1+ax], bx      ; byte [1+ax] - bx
  cmp [1+ax], 1       ; byte [1+ax] - 1
  cmp word ax, bx      ; ax - bx
  cmp word ax, [bx]    ; ax - word [bx]
  cmp word ax, [bx+cx] ; ax - word [bx+cx]
  cmp word ax, 1       ; ax - 1
  cmp word ax, [1]     ; ax - word [1]
  cmp word ax, [1+bx]  ; ax - word [1+bx]
  cmp word [ax], bx    ; word [ax] - bx
  cmp word [ax], 1     ; word [ax] - 1
  cmp word [ax+cx], bx ; word [ax+cx] - bx
  cmp word [ax+cx], 1  ; word [ax+cx] - 1
  cmp word [1], ax     ; word [1] - ax
  cmp word [1], 1      ; word [1] - 1
  cmp word [1+ax], bx  ; word [1+ax] - bx
  cmp word [1+ax], 1   ; word [1+ax] - 1

 Смотри также:
  {Арифметические команды:MatCom}
  {ADD}        {SUB}
  {MUL}        {DIV}
  {INC}        {DEC}
  {NEG}

  {главное меню информационной системы:InfoSystem}

.topic LogCom
 ─ Логические команды ────────────────────

   Логические  команды  предназначены  для
 проведения  простых  логических  операций
 над  значения хранящимися в регистрах или
 в   памяти.   Далее   идет   список  всех
 логических   команд,  выбрав  нужную  Вам
 перейдите  на  страницу содержащюю помощь
 по этой команде.

 Смотри также:
  {AND}        {OR}
  {XOR}        {NOT}
  {TEST}

  {главное меню информационной системы:InfoSystem}

.topic AND
 ─ Логические команды ────────────────────

 AND назначение, источник
 ─────────────────────────────────────────
   Эта    команда    выполняет    действие
 называемое  побитовое  И для назначения и
 источника,    а    результат   помещает в
 назначение.
   В  качестве  источника  могут выступать
 регисры,  числа  и значение в памяти. А в
 качестве   назначения  только  регистры и
 значение   в   памяти.  Если  в  качестве
 источника   или  назначения  используется
 значение  в  памяти  -  Вы должны указать
 явным    образом    тип   информации   по
 указанному адресу (см. {MOV})
   При использования этой команды значение
 источника не меняется.
   Результат    операции   анализируется и
 согласно правилам  (см. {Регистры и флаги:RegVP})
 изменяются значения нужных флагов.

 Пример использования команды and:
  and ax, bx          ; ax = ax & bx
  and ax, [bx]        ; ax = ax & byte [bx]
  and ax, [bx+cx]     ; ax = ax & byte [bx+cx]
  and ax, 1           ; ax = ax & 1
  and ax, [1]         ; ax = ax & byte [1]
  and ax, [1+bx]      ; ax = ax & byte [1+bx]
  and [ax], bx        ; byte [ax] = byte [ax] & bx
  and [ax], 1         ; byte [ax] = byte [ax] & 1
  and [ax+cx], bx     ; byte [ax+cx] = byte [ax+cx] & bx
  and [ax+cx], 1      ; byte [ax+cx] = byte [ax+cx] & 1
  and [1], ax         ; byte [1] = byte [1] & ax
  and [1], 1          ; byte [1] = byte [1] & 1
  and [1+ax], bx      ; byte [1+ax] = byte [1+ax] & bx
  and [1+ax], 1       ; byte [1+ax] = byte [1+ax] & 1
  and word ax, bx      ; ax = ax & bx
  and word ax, [bx]    ; ax = ax & word [bx]
  and word ax, [bx+cx] ; ax = ax & word [bx+cx]
  and word ax, 1       ; ax = ax & 1
  and word ax, [1]     ; ax = ax & word [1]
  and word ax, [1+bx]  ; ax = ax & word [1+bx]
  and word [ax], bx    ; word [ax] = word [ax] & bx
  and word [ax], 1     ; word [ax] = word [ax] & 1
  and word [ax+cx], bx ; word [ax+cx] = word [ax+cx] & bx
  and word [ax+cx], 1  ; word [ax+cx] = word [ax+cx] & 1
  and word [1], ax     ; word [1] = word [1] & ax
  and word [1], 1      ; word [1] = word [1] & 1
  and word [1+ax], bx  ; word [1+ax] = word [1+ax] & bx
  and word [1+ax], 1   ; word [1+ax] = word [1+ax] & 1

 Смотри также:
  {Логические команды:LogCom}
  {OR}         {XOR}
  {NOT}        {TEST}

  {главное меню информационной системы:InfoSystem}

.topic OR
 ─ Логические команды ────────────────────

 OR назначение, источник
 ─────────────────────────────────────────
   Эта    команда    выполняет    действие
 называемое  побитовое  ИЛИ для назначения
 и   источника,   а  результат  помещает в
 назначение.
   В  качестве  источника  могут выступать
 регисры,  числа  и значение в памяти. А в
 качестве   назначения  только  регистры и
 значение   в   памяти.  Если  в  качестве
 источника   или  назначения  используется
 значение  в  памяти  -  Вы должны указать
 явным    образом    тип   информации   по
 указанному адресу (см. {MOV})
   При использования этой команды значение
 источника не меняется. Результат операции
 анализируется    и    согласно   правилам
 (см. {Регистры и флаги:RegVP})         изменяются
 значения нужных флагов.

 Пример использования команды or:
  or ax, bx           ; ax = ax | bx
  or ax, [bx]         ; ax = ax | byte [bx]
  or ax, [bx+cx]      ; ax = ax | byte [bx+cx]
  or ax, 1            ; ax = ax | 1
  or ax, [1]          ; ax = ax | byte [1]
  or ax, [1+bx]       ; ax = ax | byte [1+bx]
  or [ax], bx         ; byte [ax] = byte [ax] | bx
  or [ax], 1          ; byte [ax] = byte [ax] | 1
  or [ax+cx], bx      ; byte [ax+cx] = byte [ax+cx] | bx
  or [ax+cx], 1       ; byte [ax+cx] = byte [ax+cx] | 1
  or [1], ax          ; byte [1] = byte [1] | ax
  or [1], 1           ; byte [1] = byte [1] | 1
  or [1+ax], bx       ; byte [1+ax] = byte [1+ax] | bx
  or [1+ax], 1        ; byte [1+ax] = byte [1+ax] | 1
  or word ax, bx       ; ax = ax | bx
  or word ax, [bx]     ; ax = ax | word [bx]
  or word ax, [bx+cx]  ; ax = ax | word [bx+cx]
  or word ax, 1        ; ax = ax | 1
  or word ax, [1]      ; ax = ax | word [1]
  or word ax, [1+bx]   ; ax = ax | word [1+bx]
  or word [ax], bx     ; word [ax] = word [ax] | bx
  or word [ax], 1      ; word [ax] = word [ax] | 1
  or word [ax+cx], bx  ; word [ax+cx] = word [ax+cx] | bx
  or word [ax+cx], 1   ; word [ax+cx] = word [ax+cx] | 1
  or word [1], ax      ; word [1] = word [1] | ax
  or word [1], 1       ; word [1] = word [1] | 1
  or word [1+ax], bx   ; word [1+ax] = word [1+ax] | bx
  or word [1+ax], 1    ; word [1+ax] = word [1+ax] | 1

 Смотри также:
  {Логические команды:LogCom}
  {AND}        {XOR}
  {NOT}        {TEST}

  {главное меню информационной системы:InfoSystem}

.topic XOR
 ─ Логические команды ────────────────────

 XOR назначение, источник
 ─────────────────────────────────────────
   Эта    команда    выполняет    действие
 называемое  побитовое исключающее ИЛИ для
 назначения   и   источника,  а  результат
 помещает в назначение.
   В  качестве  источника  могут выступать
 регисры,  числа  и значение в памяти. А в
 качестве   назначения  только  регистры и
 значение   в   памяти.  Если  в  качестве
 источника   или  назначения  используется
 значение  в  памяти  -  Вы должны указать
 явным    образом    тип   информации   по
 указанному адресу (см. {MOV})
   При использования этой команды значение
 источника не меняется. Результат операции
 анализируется    и    согласно   правилам
 (см. {Регистры и флаги:RegVP})         изменяются
 значения нужных флагов.

 Пример использования команды xor:
  xor ax, bx          ; ax = ax ^ bx
  xor ax, [bx]        ; ax = ax ^ byte [bx]
  xor ax, [bx+cx]     ; ax = ax ^ byte [bx+cx]
  xor ax, 1           ; ax = ax ^ 1
  xor ax, [1]         ; ax = ax ^ byte [1]
  xor ax, [1+bx]      ; ax = ax ^ byte [1+bx]
  xor [ax], bx        ; byte [ax] = byte [ax] ^ bx
  xor [ax], 1         ; byte [ax] = byte [ax] ^ 1
  xor [ax+cx], bx     ; byte [ax+cx] = byte [ax+cx] ^ bx
  xor [ax+cx], 1      ; byte [ax+cx] = byte [ax+cx] ^ 1
  xor [1], ax         ; byte [1] = byte [1] ^ ax
  xor [1], 1          ; byte [1] = byte [1] ^ 1
  xor [1+ax], bx      ; byte [1+ax] = byte [1+ax] ^ bx
  xor [1+ax], 1       ; byte [1+ax] = byte [1+ax] ^ 1
  xor word ax, bx      ; ax = ax ^ bx
  xor word ax, [bx]    ; ax = ax ^ word [bx]
  xor word ax, [bx+cx] ; ax = ax ^ word [bx+cx]
  xor word ax, 1       ; ax = ax ^ 1
  xor word ax, [1]     ; ax = ax ^ word [1]
  xor word ax, [1+bx]  ; ax = ax ^ word [1+bx]
  xor word [ax], bx    ; word [ax] = word [ax] ^ bx
  xor word [ax], 1     ; word [ax] = word [ax] ^ 1
  xor word [ax+cx], bx ; word [ax+cx] = word [ax+cx] ^ bx
  xor word [ax+cx], 1  ; word [ax+cx] = word [ax+cx] ^ 1
  xor word [1], ax     ; word [1] = word [1] ^ ax
  xor word [1], 1      ; word [1] = word [1] ^ 1
  xor word [1+ax], bx  ; word [1+ax] = word [1+ax] ^ bx
  xor word [1+ax], 1   ; word [1+ax] = word [1+ax] ^ 1

 Смотри также:
  {Логические команды:LogCom}
  {AND}        {OR}
  {NOT}        {TEST}

  {главное меню информационной системы:InfoSystem}

.topic NOT
 ─ Логические команды ────────────────────

 NOT назначение
 ─────────────────────────────────────────
   Эта    команда    выполняет    действие
 называемое побитовое НЕТ для назначения.
   В  качестве  назначения могут выступать
 только регистры и значение в памяти. Если
 в    качестве   назначения   используется
 значение  в  памяти  -  Вы должны указать
 явным    образом    тип   информации   по
 указанному адресу (см. {MOV})
   Результат    операции   анализируется и
 согласно правилам  (см. {Регистры и флаги:RegVP})
 изменяются значения нужных флагов.

 Пример использования команды not:
  not ax           ; ax = not ax
  not [ax]         ; byte [ax] = not byte [ax]
  not [ax+bx]      ; byte [ax+bx] = not byte [ax+bx]
  not [1]          ; byte [1] = not byte [1]
  not [1+ax]       ; byte [1+ax] = not byte [1+ax]
  not word [ax]    ; word [ax] = not word [ax]
  not word [ax+bx] ; word [ax+bx] = not word [ax+bx]
  not word [1]     ; word [1] = not word [1]
  not word [1+ax]  ; word [1+ax] = not word [1+ax]

 Смотри также:
  {Логические команды:LogCom}
  {AND}        {OR}
  {XOR}        {TEST}

  {главное меню информационной системы:InfoSystem}

.topic TEST
 ─ Логические команды ────────────────────

 TEST назначение, источник
 ─────────────────────────────────────────
   Эта    команда    выполняет    действие
 называемое  побитовое  И для назначения и
 источника,  но  результат  использует для
 модификации флагов.
   В  качестве  источника  могут выступать
 регисры,  числа  и значение в памяти. А в
 качестве   назначения  только  регистры и
 значение   в   памяти.  Если  в  качестве
 источника   или  назначения  используется
 значение  в  памяти  -  Вы должны указать
 явным    образом    тип   информации   по
 указанному адресу (см. {MOV})
   При использования этой команды значение
 источника и назначения не меняется.
   Результат    операции   анализируется и
 согласно правилам  (см. {Регистры и флаги:RegVP})
 изменяются значения нужных флагов.

 Пример использования команды test:
  test ax, bx          ; ax & bx
  test ax, [bx]        ; ax & byte [bx]
  test ax, [bx+cx]     ; ax & byte [bx+cx]
  test ax, 1           ; ax & 1
  test ax, [1]         ; ax & byte [1]
  test ax, [1+bx]      ; ax & byte [1+bx]
  test [ax], bx        ; byte [ax] & bx
  test [ax], 1         ; byte [ax] & 1
  test [ax+cx], bx     ; byte [ax+cx] & bx
  test [ax+cx], 1      ; byte [ax+cx] & 1
  test [1], ax         ; byte [1] & ax
  test [1], 1          ; byte [1] & 1
  test [1+ax], bx      ; byte [1+ax] & bx
  test [1+ax], 1       ; byte [1+ax] & 1
  test word ax, bx      ; ax & bx
  test word ax, [bx]    ; ax & word [bx]
  test word ax, [bx+cx] ; ax & word [bx+cx]
  test word ax, 1       ; ax & 1
  test word ax, [1]     ; ax & word [1]
  test word ax, [1+bx]  ; ax & word [1+bx]
  test word [ax], bx    ; word [ax] & bx
  test word [ax], 1     ; word [ax] & 1
  test word [ax+cx], bx ; word [ax+cx] & bx
  test word [ax+cx], 1  ; word [ax+cx] & 1
  test word [1], ax     ; word [1] & ax
  test word [1], 1      ; word [1] & 1
  test word [1+ax], bx  ; word [1+ax] & bx
  test word [1+ax], 1   ; word [1+ax] & 1

 Смотри также:
  {Логические команды:LogCom}
  {AND}        {OR}
  {XOR}        {NOT}

  {главное меню информационной системы:InfoSystem}

.topic StreamCom
 ─ Команды управления потоком ────────────

   Команды    управления   потоком   можно
 разделить   на   две   части   -  команды
 условного   изменения  потока  и  команды
 безусловного    изменения   потока.   Это
 означает,  что  имеются  команды, которые
 изменяют   последовательность  выполнения
 программы   всегда   одинаково,   а  есть
 команды,         которые         изменяют
 последовательность,       только      при
 определенных условиях(значениях флагов).
   Кроме  того,  еще есть команды, которые
 изменяют последовательность выполнения, с
 дальнейшей возможность вернуться к адресу
 памяти, где была встречена такая команда.
   Так   же,   имеется   команда,  которая
 отличается   от  всех  других,  тем,  что
 позволяет  временно  передать  управление
 ядру   виртуальной  машины,  для  решения
 какой-то    сложной    задачи   или   для
 взаимодействия   с  каким-то  компонентом
 виртуальной  машины.  Далее  идет  список
 всех  команд  управления  потоком, выбрав
 нужную    Вам   перейдите   на   страницу
 содержащюю помощь по этой команде.

 Смотри также:
  {CALL}                {JMP}
  {RET}                 {CSP}
  {JRZ}                 {JRNZ}
  {J<условие>:Jif}          {JN<условие>:JNif}

  {главное меню информационной системы:InfoSystem}

.topic CALL
 ─ Команды управления потоком ────────────

 CALL адрес
 ─────────────────────────────────────────
   Эта  команда делает следующие действия:
 помещает    в    стек   адрес   следующей
 команды,  а в регистр LIP помещает адрес,
 указанный в качестве параметра.
   В качестве адреса может выступать число
 или   регистр.   При  использование  этой
 команды значение адреса не меняется.

 Пример использования команды call:
  call 0      ; push LIP   mov LIP, 0
  call ax     ; push LIP   mov LIP, ax
  call 0+ax   ; push LIP   mov LIP, 0   add LIP, ax
  call ax+bx  ; push LIP   mov LIP, ax  add LIP, bx

 Смотри также:
  {Команды управления потоком:StreamCom}
  {JMP}                 {RET}
  {CSP}                 {JRZ}
  {JRNZ}                {J<условие>:Jif}
  {JN<условие>:JNif}

  {главное меню информационной системы:InfoSystem}

.topic JMP
 ─ Команды управления потоком ────────────

 JMP адрес
 ─────────────────────────────────────────
   Эта  команда  помещает  в  регистр  LIP
 адрес, указанный в качестве параметра.
   В качестве адреса может выступать число
 или регистр.
   При использование этой команды значение
 адреса не меняется.

 Пример использования команды jmp:
  jmp 0         ; mov LIP, 0
  jmp ax        ; mov LIP, ax
  jmp 0+ax      ; mov LIP, 0   add LIP, ax
  jmp ax+bx     ; mov LIP, ax  add LIP, bx

 Смотри также:
  {Команды управления потоком:StreamCom}
  {CALL}                {RET}
  {CSP}                 {JRZ}
  {JRNZ}                {J<условие>:Jif}
  {JN<условие>:JNif}

  {главное меню информационной системы:InfoSystem}

.topic RET
 ─ Команды управления потоком ────────────

 RET
 ─────────────────────────────────────────
   Эта  команда  помещает  в  регистр  LIP
 восьмибайтовое     число     хранящееся в
 вершине  стека.  С  помощью  этой команды
 можно   вернуться   к   тому   месту  где
 последний  раз  встретилась команда call,
 так   как   она  помещает  в  стек  адрес
 следующей команды.

 Пример использования команды ret:
  ret               ; mov qword LIP, [LSP]

 Смотри также:
  {Команды управления потоком:StreamCom}
  {CALL}                {JMP}
  {CSP}                 {JRZ}
  {JRNZ}                {J<условие>:Jif}
  {JN<условие>:JNif}

  {главное меню информационной системы:InfoSystem}

.topic CSP
 ─ Команды управления потоком ────────────

 CSP назначение
 ─────────────────────────────────────────
   Эта     команда    временно    передает
 управление   функции   ядра   с   номером
 назначение.   С   помощью   этой  команды
 осуществляется     доступ     ко     всем
 компонентам виртуальной машины.
   В  качестве  назначения может выступать
 регистр или число.
   При использовании этой команды значение
 назначения не меняется.
   При использовании этой команды значения
 регистра  LIP  не  меняется,  но меняются
 значения  других регистров, в зависомости
 от вызванной функции.

 Пример использования команды csp:
  csp 0   ; передать управление функции ядра с номером 0
  csp ax  ; передать управление функции ядра с номером
          ; хранящимся в регистре ax

 Смотри также:
  {Команды управления потоком:StreamCom}
  {CALL}                {JMP}
  {RET}                 {JRZ}
  {JRNZ}                {J<условие>:Jif}
  {JN<условие>:JNif}

  {главное меню информационной системы:InfoSystem}

.topic JRZ
 ─ Команды управления потоком ────────────

 JRZ регистр, адрес
 ─────────────────────────────────────────
   Эта  команда  помещает  в  регистр  LIP
 адрес,  указанный  в  качестве  параметра
 тогда  и  только  тогда,  когда  значение
 регистра,    переданного    в    качестве
 параметра, равно 0.
   В качестве адреса может выступать число
 или регистр.
   При использование этой команды значение
 адреса и регистра не меняется.

 Пример использования команды jrz:
  jrz ax, 0     ; если ax = 0 то mov LIP, 0
  jrz ax, bx    ; если ax = 0 то mov LIP, bx
  jrz ax, 0+bx  ; если ax = 0 то ( mov LIP, 0   add LIP, bx )
  jrz ax, bx+cx ; если ax = 0 то ( mov LIP, bx  add LIP, cx )

 Смотри также:
  {Команды управления потоком:StreamCom}
  {CALL}                {JMP}
  {RET}                 {CSP}
  {JRNZ}                {J<условие>:Jif}
  {JN<условие>:JNif}

  {главное меню информационной системы:InfoSystem}

.topic JRNZ
 ─ Команды управления потоком ────────────

 JRNZ регистр, адрес
 ─────────────────────────────────────────
   Эта  команда  помещает  в  регистр  LIP
 адрес,  указанный  в  качестве  параметра
 тогда  и  только  тогда,  когда  значение
 регистра,    переданного    в    качестве
 параметра, не равно 0.
   В качестве адреса может выступать число
 или регистр.
   При использование этой команды значение
 адреса и регистра не меняется.

 Пример использования команды jrnz:
  jrnz ax, 0      ; если ax <> 0 то mov LIP, 0
  jrnz ax, bx     ; если ax <> 0 то mov LIP, bx
  jrnz ax, 0+bx   ; если ax <> 0 то ( mov LIP, 0   add LIP, bx )
  jrnz ax, bx+cx  ; если ax <> 0 то ( mov LIP, bx  add LIP, cx )

 Смотри также:
  {Команды управления потоком:StreamCom}
  {CALL}                {JMP}
  {RET}                 {CSP}
  {JRZ}                 {J<условие>:Jif}
  {JN<условие>:JNif}

  {главное меню информационной системы:InfoSystem}

.topic Jif
 ─ Команды управления потоком ────────────

 J<условие> адрес
 ─────────────────────────────────────────
   Эта  команда  помещает  в  регистр  LIP
 адрес,  указанный  в  качестве  параметра
 тогда   и   только   тогда,   когда  флаг
 указанный  в качестве условия равен 1 или
 если в качестве условия указанна буква G,
 L   или   E,  то  тогда,  если  результат
 математической  или  логической  операции
 больше,     меньше     или    равен    0,
 соответственно.
   В качестве адреса может выступать число
 или регистр.
   В   качестве  условия  может  выступать
 буква  названия  флага  или  G, L, E, как
 написано выше.
   При использование этой команды значение
 адреса и регистра не меняется.

 Пример использования команды j<условие>:
  jo 0      ; если флаг O = 1 то mov LIP, 0
  jc ax     ; если флаг C = 1 то mov LIP, ax
  je 0+ax   ; если резул. операции = 0 то mov LIP, 0  add LIP,ax
  ja ax+bx  ; если флаг A = 1 то mov LIP, ax  add LIP, bx

 Смотри также:
  {Команды управления потоком:StreamCom}
  {CALL}                {JMP}
  {RET}                 {CSP}
  {JRZ}                 {JRNZ}
  {JN<условие>:JNif}

  {главное меню информационной системы:InfoSystem}

.topic JNif
 ─ Команды управления потоком ────────────

 JN<условие> адрес
 ─────────────────────────────────────────
   Эта  команда  помещает  в  регистр  LIP
 адрес,  указанный  в  качестве  параметра
 тогда   и   только   тогда,   когда  флаг
 указанный  в качестве условия равен 0 или
 если в качестве условия указанна буква G,
 L   или   E,  то  тогда,  если  результат
 математической  или  логической  операции
 небольше,   неменьше   или   неравен   0,
 соответственно.
   В качестве адреса может выступать число
 или регистр.
   В   качестве  условия  может  выступать
 буква  названия  флага  или  G, L, E, как
 написано выше.
   При использование этой команды значение
 адреса и регистра не меняется.

 Пример использования команды jn<условие>:
  jno 0      ; если флаг O = 0 то mov LIP, 0
  jnc ax     ; если флаг C = 0 то mov LIP, ax
  jne 0+ax   ; если резул. операции <> 0 то mov LIP, 0  add LIP,ax
  jna ax+bx  ; если флаг A = 0 то mov LIP, ax  add LIP, bx

 Смотри также:
  {Команды управления потоком:StreamCom}
  {CALL}                {JMP}
  {RET}                 {CSP}
  {JRZ}                 {JRNZ}
  {J<условие>:Jif}

  {главное меню информационной системы:InfoSystem}

.topic VPCom
 ─ Команды управления процессором ────────

   Команды  этой группы предназначенны для
 изменения  состояния работы процессора, а
 именно,  для  модификации  флагов.  Кроме
 того  к  командам  этой  группы  я  отнес
 пустую  операцию,  так  как  она изменяет
 только   значение   регистра   LIP,   что
 соответствует   назначению  этой  группы.
 Далее    идет    список    всех    команд
 управления  виртуальным  процессором с их
 полным описанием и параметрами.

 Смотри также:
  {CL<флаг>:CLf}
  {ST<флаг>:STf}
  {NOP}

  {главное меню информационной системы:InfoSystem}

.topic CLf
 ─ Команды управления процессором ────────

 CL<флаг>
 ─────────────────────────────────────────
   Эта  команда  помещает в указанный флаг
 0.
   В   качестве  условия  может  выступать
 буква названия флага.

 Пример использования команды cl<флаг>:
  clo                 ; флаг O = 0
  cls                 ; флаг S = 0
  clz                 ; флаг Z = 0
  cla                 ; флаг A = 0

 Смотри также:
  {Команды управления процессором:VPCom}
  {ST<флаг>:STf}
  {NOP}

  {главное меню информационной системы:InfoSystem}

.topic STf
 ─ Команды управления процессором ────────

 ST<флаг>
 ─────────────────────────────────────────
   Эта  команда  помещает в указанный флаг
 1.
   В   качестве  условия  может  выступать
 буква названия флага.

 Пример использования команды st<флаг>:
  sto                 ; флаг O = 1
  sts                 ; флаг S = 1
  stz                 ; флаг Z = 1
  sta                 ; флаг A = 1

 Смотри также:
  {Команды управления процессором:VPCom}
  {CL<флаг>:CLf}
  {NOP}

  {главное меню информационной системы:InfoSystem}

.topic NOP
 ─ Команды управления процессором ────────

 NOP
 ─────────────────────────────────────────
   Эта   команда   трактуется  как  пустая
 операция.   Когда  виртуальный  процессор
 встречает    эту   команду,   он   просто
 увеличивает   значение  регистра  LIP  на
 размер этой команды.

 Пример использования команды nop:
  nop                 ; add LIP, SizeOf(nop)

 Смотри также:
  {Команды управления процессором:VPCom}
  {CL<флаг>:CLf}
  {ST<флаг>:STf}

  {главное меню информационной системы:InfoSystem}


