

                   ████████    ██      ██   ██        ██ TM
                  ██      ██   ██      ██   ███      ███
                  ██  ░░░░░░░░ ██░░    ██ ░░████░   ████ ░░ ░░
                  ██ ░░      ░░██░░    ██ ░░██ ██░ ██ ██░░░
                   ████████     ██░   ██  ░░██ ░████  ██░░░
                     ░░   ██    ██░   ██  ░░██ ░░██░  ██ ░░
                      ░░░░██░░   ██░ ██  ░░ ██ ░░  ░░░██ ░░
                  ██      ██ ░░   ████   ░░ ██ ░░   ░░██ ░░
                   ████████  ░░    ██░  ░░  ██ ░░     ██ ░░
                     ░░      ░░      ░░░░      ░░        ░░
                      ░░░░░░░░        ░░       ░░        ░░

                                SVM Assembler


                        Copyright (C) 1999 ShAG Studio


                                Luhansk, 1999


                          УЧЕБНИК ПО SVM АССЕМБЛЕРУ.

                                 ОГЛАВЛЕНИЕ:
          1. Виртуальная машина.
          2. Числа и типы данных.
          3. Регистры и флаги.
          4. Размещение программы в памяти, стек.
          5. Команды виртуальной машины.
          6. Команды перемещения информации.
          7. Арефметические команды.
          8. Логические команды.
          9. Команды управления потоком.
          10. Команды управления виртуальным процессором


 1. ВИРТУАЛЬНАЯ МАШИНА.
 ────────────────────────────────────────────────────────────────────────────
    Виртуалная  машина  -  это  набор  виртуальных  устройств, к которым Ваша
 программа  может  обращаться,  но  которых  может  и не существовать в вашем
 компьютере. Это полная независимость от платформы, которая достигается путем
 создания виртуального процессора.
    На   данный   момент,  виртуальная  машина  позволяет  вам:  использовать
 64-битное  адресное  пространство  (если  у  вас  хватит  места  на  диске),
 обмениваться  информацией  с  графическим устройством, при этом вы работаете
 всегда   с  24-битной  графикой,  независимо  от  видеоадаптера,  работать с
 файлами, использовать указательное устройство типа "мышь", даже в том случае
 если  оно  отсутствует.  В  скором  времени,  ожидается  потдержка  звуковых
 устройств,  даже  если  они  будут  отсутствовать,  и потдержка сети. Также,
 вскором  времени  должны  появиться  команды для запуска приложений подобных
 себе,   а   также   совместное   исполнение   сразу   нескольких  программ -
 многозадачность.
    Чтобы Вы могли понять как это работает ниже приведен схема взаимодействия
 программы  с  виртуальной  машиной  и  её отдельными компонентами. Стрелочки
 указывают кто с кем может общаться.

    ┌──────────────────┐    ┌───────────────┐    ┌───────────────────┐
    │ Программа, как   │    │ Ядро          │    │ Вся доступная     │
    │ алгоритм исполь- ├───│ виртуальной   │───┤ системе память, в │
    │ зования всех     │    │ машины кон-   │    │ том числе и       │
    │ компонентов для  │───┤ тролирует     ├───│ виртуальная       │
    │ достижения цели  │    │ правильность  │    │                   │
    └──────────┬───────┘    │ и легальность │    └───────┬───────────┘
                          │ доступа ко    │              
    ┌───────┴──────────┐    │ всем компо-   │    ┌──────────┴────────┐
    │ Память программы │    │ нентам        │    │ Все доступные     │
    │ - базовый компо- │───┤ виртуальной   ├───│ системе устрой-   │
    │ нент, не имеющий │    │ машины        │    │ ства, в том числе │
    │ ограничения в    ├───│               │───┤ и виртуальные     │
    │ доступе          │    │               │    │                   │
    └──────────────────┘    └───────────────┘    └───────────────────┘

    Я принял эту схему для построения структуры взаимодействия программы
 со всеми компонентами виртуальной машины по нескольким причинам:
  ■ во-первых,  такая  схема  полностью  блокирует нелегальный доступ ко всей
 памяти компьютера, что повышает коэфициент безопасности системы;
  ■ во-вторых, эта схема дает неограниченные возможности по изменению состава
 компонентов,  так  как  программа  узнает о работоспособности компонентов от
 ядра.  Это  дает возможность подключить к ядру модуль эмуляции отсутствующих
 компонентов  и  при  этом  не  пострадает  программа, которая использует эти
 компоненты;
  ■ в-третьих,  такая  схема  позволяет легко адаптировать данную виртуальную
 машину к любой проблеме, так как очень лекго изменить состав компонентов.


 2. ЧИСЛА И ТИПЫ ДАННЫХ.
 ────────────────────────────────────────────────────────────────────────────
    При  работе  с виртуальной машиной вы сможете использовать следующие типы
 данных: беззнаковый однобайтовый целый, знаковый двухбайтный целый, знаковый
 четырехбайтный  целый,  знаковый восьмибайтный целый. Диапазон значений этих
 чисел  приведены в документе svmac.doc в главе 5. ЧИСЛА. Если вы попытаетесь
 занести  в  переменную  беззнакового типа значение со знаком, то не получите
 правельного  результата.  Если вы попытаетесь занести в переменную значение,
 выходящее   за  пределы  диапазона  допустимых  значений,  то  в  переменную
 занесутся  только  те  байты,  которые  не  выходят  за  диапазон допустимых
 значений.
    Числа хранятся в следующем виде, младший бит находится с левой стороны, а
 старший  -  с  правой,  это  же  относиться  и  ко всем структурам - байтам,
 словам.  В  данной  версии виртуальной машины стратегия работы с битами и их
 точного  расположения  еще  не  разработана,  поэтому в следующей версии она
 может  измениться.  При  разработке  команд  виртуальной  машины, я старался
 снизить  зависимость  смысла  команд  от  расположения бит, поэтому, если вы
 небудете  делать сильно заумные вещи с битами, возможно у вас и не возникнет
 проблема с их расположением.


 3. РЕГИСТРЫ И ФЛАГИ.
 ────────────────────────────────────────────────────────────────────────────
    Регистры предназначены для управления виртуальным процессорм, а также для
 проведения  любых  арефметических,  логических действий. Всего в виртуальном
 процессоре  41  регистр.  Одинадцать  из  них  - 8-байтные, еще одинадцать -
 4-байтные, еще одинадцать - 2-байтные и еще восемь - 1-байтные. Некоторые из
 этих   регистров  можно  испоьзовать  по  своему  усмотрению,  а  некоторые,
 используются для работы виртуального процессора. Дальше приводится таблица с
 именами, размерами и значениями каждого регистра.

     Регистр   общего   назначения,  в  основном  используется  для  хранения
 результата  какойто  математической  операции, но может использоваться и для
 других целей.
     ┌─────────────────────────────────────┐
     │                 LAX                 │ - 8-байтный регистр
     ├──────────────────┬──────────────────┤
     │        EAX       │                  │ - 4-байтный регистр
     ├─────────┬────────┼──────────────────┤
     │   AX    │        │                  │ - 2-байтный регистр
     ├────┬────┼────────┼──────────────────┤
     │ AL │ AH │        │                  │ два 1-байтных регистра
     └────┴────┴────────┴──────────────────┘

     Регистр общего назначения.
     ┌─────────────────────────────────────┐
     │                 LBX                 │ - 8-байтный регистр
     ├──────────────────┬──────────────────┤
     │        EBX       │                  │ - 4-байтный регистр
     ├─────────┬────────┼──────────────────┤
     │   BX    │        │                  │ - 2-байтный регистр
     ├────┬────┼────────┼──────────────────┤
     │ BL │ BH │        │                  │ два 1-байтных регистра
     └────┴────┴────────┴──────────────────┘

     Регистр общего назначения, в основном используется как счетчик в циклах,
 но может использоваться и для других целей.
     ┌─────────────────────────────────────┐
     │                 LCX                 │ - 8-байтный регистр
     ├──────────────────┬──────────────────┤
     │        ECX       │                  │ - 4-байтный регистр
     ├─────────┬────────┼──────────────────┤
     │   CX    │        │                  │ - 2-байтный регистр
     ├────┬────┼────────┼──────────────────┤
     │ CL │ CH │        │                  │ два 1-байтных регистра
     └────┴────┴────────┴──────────────────┘

     Регистр общего назначения.
     ┌─────────────────────────────────────┐
     │                 LDX                 │ - 8-байтный регистр
     ├──────────────────┬──────────────────┤
     │        EDX       │                  │ - 4-байтный регистр
     ├─────────┬────────┼──────────────────┤
     │   DX    │        │                  │ - 2-байтный регистр
     ├────┬────┼────────┼──────────────────┤
     │ DL │ DH │        │                  │ два 1-байтных регистра
     └────┴────┴────────┴──────────────────┘

     Регистр  начала  стека,  указвает  на  начало  стека  в  памяти, при его
 изменении  можно  добиться  такого  расположения  стека  в  памяти, как надо
 программисту.
     ┌─────────────────────────────────────┐
     │                 LSS                 │ - 8-байтный регистр
     ├──────────────────┬──────────────────┤
     │        ESS       │                  │ - 4-байтный регистр
     ├─────────┬────────┼──────────────────┤
     │   SS    │        │                  │ - 2-байтный регистр
     └─────────┴────────┴──────────────────┘

     Стековый указатель, указывает на голову стека относительно начала стека,
 если равен нулю, то стек пуст.
     ┌─────────────────────────────────────┐
     │                 LSP                 │ - 8-байтный регистр
     ├──────────────────┬──────────────────┤
     │        ESP       │                  │ - 4-байтный регистр
     ├─────────┬────────┼──────────────────┤
     │   SP    │        │                  │ - 2-байтный регистр
     └─────────┴────────┴──────────────────┘

     Командный указатель, указывает на адрес следующей команды, которую будет
 исполнять виртуальный процессор, при изменении значения этого регистра можно
 изменить последовательность выполнения команд.
     ┌─────────────────────────────────────┐
     │                 LIP                 │ - 8-байтный регистр
     ├──────────────────┬──────────────────┤
     │        EIP       │                  │ - 4-байтный регистр
     ├─────────┬────────┼──────────────────┤
     │   IP    │        │                  │ - 2-байтный регистр
     └─────────┴────────┴──────────────────┘

     Дополнительный   указатель,  обычно  используется  как  адрес  источника
 какой-то информации, но может использоваться и для других целей.
     ┌─────────────────────────────────────┐
     │                 LEP                 │ - 8-байтный регистр
     ├──────────────────┬──────────────────┤
     │        EEP       │                  │ - 4-байтный регистр
     ├─────────┬────────┼──────────────────┤
     │   EP    │        │                  │ - 2-байтный регистр
     └─────────┴────────┴──────────────────┘

     Дополнительный  указатель,  обычно  используется  как  адрес  назначения
 какой-то информации, но может использоваться и для других целей.
     ┌─────────────────────────────────────┐
     │                 LFP                 │ - 8-байтный регистр
     ├──────────────────┬──────────────────┤
     │        EFP       │                  │ - 4-байтный регистр
     ├─────────┬────────┼──────────────────┤
     │   FP    │        │                  │ - 2-байтный регистр
     └─────────┴────────┴──────────────────┘

     Дополнительный указатель.
     ┌─────────────────────────────────────┐
     │                 LGP                 │ - 8-байтный регистр
     ├──────────────────┬──────────────────┤
     │        EGP       │                  │ - 4-байтный регистр
     ├─────────┬────────┼──────────────────┤
     │   GP    │        │                  │ - 2-байтный регистр
     └─────────┴────────┴──────────────────┘

     Регистр  состояния  флагов,  содержит  все  флаги  процессора,  но может
 использоваться  и  для  других  целей,  с учетом последующего востановления,
 правда  при  этом могут возникнуть проблемы с условным переходом. Введен для
 облегчения работы с флагами.
     ┌─────────────────────────────────────┐
     │                 LFS                 │ - 8-байтный регистр
     ├──────────────────┬──────────────────┤
     │        EFS       │                  │ - 4-байтный регистр
     ├─────────┬────────┼──────────────────┤
     │   FS    │        │                  │ - 2-байтный регистр
     └─────────┴────────┴──────────────────┘

     Флаги  предназначены  для  указания  программе на какое-то изменение или
 ошибку  при  работе виртуального процессора. Дальше приведена таблица флагов
 и их назначение.

  ■  Флаг O -  флаг переполнения.  Равен 1 если в результате математической
     операции  получилось значение выходящие  за пределы источника, во всех
     других случаях равен 0.

  ■  Флаг S - флаг знака. Равен 1 если в результате математической операции
     получилось отрицательное число, во всех других случаях равен 1.

  ■  Флаг Z -  флаг нуля. Равен 1 если в результате математической операции
     получили 0, во всех других случаях равен 0.

  ■  Флаг P -  флаг  четности.   Равен 1 если  в результате  математической
     операции получили четное число, во всех других случаях равен 0.

  ■  Флаг C -  флаг  переноса.   Равен 1 если  в результате  математической
     операции произошел переход разряда, во всех других случаях равен 0.

  ■  Флаг A -  дополнительный  флаг. Может  использоваться программистом по
     своему усмотрению.


 4. РАЗМЕЩЕНИЕ ПРОГРАММЫ В ПАМЯТИ, СТЕК.
 ────────────────────────────────────────────────────────────────────────────
    Любая  программа  написанная  для моей виртуальной машины располагается в
 памяти  следующим  образом.  Память  делится  на  три блока: блок кода, блок
 данных,  блок  стека  и  свободной памяти. Блок кода имеет размер кода, блок
 данных  -  даных,  блок  стека - сколько вы укажете при написании программы.
 Блок   кода  всегда  начинается  с  нулевого  адреса.  Блок  данных,  всегда
 начинается  сразу  после  блока  кода,  так,  что  между этими двумя блоками
 отсутствует  промежуток  неиспользуемой  памяти,  а  блок  стека и свободной
 памяти  начинается  сразу  после  блока  данных.  Адрес начала блока стека и
 свободной памяти содержится в регистре LSS. Зная это вы можете при написании
 программы  заведомо  выделить  больше  памяти  под  стека  чем  требует ваша
 программа,  а  затем при запуске программы, вы можете изменить размер стека,
 переместив  его  начало ближе к концу всей доступной программе памяти. Таким
 образом  вы  освободите  себе  требуемое количество памяти сразу после блока
 данных  и  сможете  использовать  её  по  своему  усмотрению.  Все что здесь
 написанно  ниже  пояснено  на  двух схемах. Стрелочки показывают направление
 роста стека.

   Вид памяти сразу после загрузки программы на исполнение:

     ╔═══════════╗ - 0                                   ─┐
     ║ Блок кода ║                                        │
     ║ программы ║                                        │
     ╟───────────╢ - Размер кода                          │
     ║   Блок    ║                                        │
     ║  данных   ║                                        │   Вся доступная
     ║ программы ║                                        ├─ программе память
     ╟───────────╢ - Размер кода + размер данных = LSS    │
  │  ║   Блок    ║   Начало стека                         │
  │  ║  стека и  ║                                        │
  │  ║ свободной ║   Используется только под стек         │
  │  ║  памяти   ║                                        │
    ║ программы ║                                        │
     ╚═══════════╝                                       ─┘

   Способ освобождения дополнительной памяти:

     ╔═══════════╗ - 0                                   ─┐
     ║ Блок кода ║                                        │
     ║ программы ║                                        │
     ╟───────────╢ - Размер кода                          │
     ║   Блок    ║                                        │
     ║  данных   ║                                        │
     ║ программы ║                                        │   Вся доступная
     ╟───────────╢ - Размер кода + размер данных          ├─ программе память
     ║           ║                                        │
     ║ Свободная ║   Используете как хотите               │
     ║  память   ║                                        │
     ║           ║                                        │
  │  ╟─ ─ ─ ─ ─ ─╢ - LSS                                  │
  │  ║   Блок    ║   Начало стека                         │
    ║  стека    ║   Используется только под стек         │
     ╚═══════════╝                                       ─┘


 5. КОМАНДЫ ВИРТУАЛЬНОГО ПРОЦЕССОРА.
 ────────────────────────────────────────────────────────────────────────────
    Все  команды  виртуального  процессора  можно  разделить  на  пять типов:
 команды  перемещения информации, арифметические команды, логические команды,
 команды управления потоком и команды управления виртуальным процессором. Все
 они будут рассмотрены и подробно описанны в последующих одноименных главах.


 6. КОМАНДЫ ПЕРЕМЕЩЕНИЯ ИНФОРМАЦИИ.
 ────────────────────────────────────────────────────────────────────────────
    Команды  перемещения  информации  предназначены  для  изменения  значений
 хранящихся  по  каким-то  адресам  и дальнейшем их использовании. Далее идет
 список   всех   команд   перемещения  информации  с  их  полным  описанием и
 параметрами.

     MOV назначение, источник
    ─────────────────────────────────────────────────────────────────────────
      Эта  команда  является  одной  из  главных  команд,  т.к. она позволяет
     перемещать  данный  между  памятью  и  регистрами.  Вкачестве параметров
     команда должна получать два параметра: назначение и источник. Назначение
     - это то куда надо переместить информацию. Источник - это то откуда надо
     переместить  информацию  или  что  переместить.  В  качестве  назначения
     допускается использовать один из регистров или адрес в памяти.
      Если  вы используете в качестве назначения - регистр, то в этот регистр
     будет помещенно соответствующее значение. Если вы используете в качестве
     назначения - адрес в памяти, то соответствующее значение по этому адресу
     будет изменено.
      При  формировании  адреса  в  памяти  вы  можете задать его несколькими
     спосабами. Первый способ - вы указываете имя переменной или сразу число,
     незабыв  при  этом  взять его в квадратные скобки, т.к. вы хотите задать
     адрес.  Второй  способ  -  вы указываете регистр, при этом при пересылке
     данных,   значение  этого  регистра  будет  рассматриваться  как  адрес,
     незабутьте  взять  регистр  в  квадратные  скобки, т.к. вы хотите задать
     адрес.  Третий  способ  - это один из двух предыдущих способов, плюс то,
     что  перед  закрывающей  квадратной  скобкой вы можете поставить регистр
     через  знак  плюс,  тогда  при выполнении, значение этого регистра будет
     прибавленно к адресу заданному одним из предыдущих способов.
      В  качестве источника допускается использовать регистр, число или адрес
     в  памяти.  Если  вы  используете  в  качестве  источника  - регистр, то
     перемещаемое   значение   будет  браться  из  этого  регистра.  Если  вы
     используете  в  качестве  источника  -  число, то перемещаться будет это
     число.  Если  вы  используете  в качестве источника - адрес в памяти, то
     значение  находящееся  по  этому  адресу будет перемещаемым. При задании
     адреса, вы можете пользоваться советом по заданию адреса для назначения.
      Источник  и  назначение  не  могут быть одновременно адресами в памяти,
     т.е. пересылка иноформации из памяти в память не возможна.
      Для  точного определения типа перемещаемой информации после команды MOV
     Вы  должны  поставить  слово:  word, WORD, DWORD, QWORD - один байт, два
     байта  -  слово,  четыри  байта  - двойное слово, восемь байт - четверно
     слово  - соответственно, по умолчанию перемещается один байт. При работе
     с обоими регистрами этого можно не делать.
      Эта   команды   ни  каким  образом  не  влияет  на  флаги  виртуального
     процессора.

    Пример использования команды MOV:
     mov ax, bx          ; bx --> ax
     mov ax, [bx]        ; byte [bx] --> ax
     mov ax, [bx+cx]     ; byte [bx+cx] --> ax
     mov ax, 1           ; 1 --> ax
     mov ax, [1]         ; byte [1] --> ax
     mov ax, [1+bx]      ; byte [1+bx] --> ax
     mov [ax], bx        ; bx --> byte [ax]
     mov [ax], 1         ; 1 --> byte [ax]
     mov [ax+cx], bx     ; bx --> byte [ax+cx]
     mov [ax+cx], 1      ; 1 --> byte [ax+cx]
     mov [1], ax         ; ax --> byte [1]
     mov [1], 1          ; 1 --> byte [1]
     mov [1+ax], bx      ; bx --> byte [1+ax]
     mov [1+ax], 1       ; 1 --> byte [1+ax]
     mov word ax, bx          ; bx --> ax
     mov word ax, [bx]        ; word [bx] --> ax
     mov word ax, [bx+cx]     ; word [bx+cx] --> ax
     mov word ax, 1           ; 1 --> ax
     mov word ax, [1]         ; word [1] --> ax
     mov word ax, [1+bx]      ; word [1+bx] --> ax
     mov word [ax], bx        ; bx --> word [ax]
     mov word [ax], 1         ; 1 --> word [ax]
     mov word [ax+cx], bx     ; bx --> word [ax+cx]
     mov word [ax+cx], 1      ; 1 --> word [ax+cx]
     mov word [1], ax         ; ax --> word  [1]
     mov word [1], 1          ; 1 --> word [1]
     mov word [1+ax], bx      ; bx --> word [1+ax]
     mov word [1+ax], 1       ; 1 --> word [1+ax]

    PUSH источник
    ─────────────────────────────────────────────────────────────────────────
      Эта команда позволяет вам поместить в стек любое число. Она имеет всего
     один  параметр  -  источник  -  то, что надо помещать в стек. В качестве
     источника может выступать регистр, адрес в памяти, число.
      Если  в  качестве источника выступает адрес в памяти, вы должны указать
     явным  образом  сколько  байт  находящихся  по  этому  адресу  вы хотите
     поместить  в  стек. Для этого, вы должны после команды PUSH использовать
     те  же  слова,  что  в  команде  MOV для явного определения типа. Если в
     качестве источника выступает регистр или число, этого можно не делать.
      Эта   команды   ни  каким  образом  не  влияет  на  флаги  виртуального
     процессора.

    Пример использования команды PUSH:
     push ax             ; ax --> stack
     push 1              ; 1 --> stack
     push [ax]           ; byte [ax] --> stack
     push [ax+cx]        ; byte [ax+cx] --> stack
     push [1]            ; byte [1] --> stack
     push [1+cx]         ; byte [1+cx] --> stack
     push word [ax]      ; word [ax] --> stack
     push word [ax+cx]   ; word [ax+cx] --> stack
     push word [1]       ; word [1] --> stack
     push word [1+cx]    ; word [1+cx] --> stack

    POP назначение
    ─────────────────────────────────────────────────────────────────────────
      Эта  команда позволяет вам извлечь из стек любое число. Она имеет всего
     один  параметр - назначение - то, куда надо поместить извлеченное число.
     В качестве назанчения может выступать регистр или адрес в памяти.
      Если  в качестве назначения выступает адрес в памяти, вы должны указать
     явным  образом  сколько  байт разрешается использовать по этому адресу и
     соответственно  сколько  байт  извлекать  из стека. Для этого, вы должны
     после команды POP исопльзовать те же слова, что в команде MOV для явного
     определения  типа.  Если  в  качестве источника выступает регистр, этого
     можно не делать.
      Эта   команды   ни  каким  образом  не  влияет  на  флаги  виртуального
     процессора.

    Пример использования команды POP:
     pop ax           ; stack --> ax
     pop [ax]         ; stack --> byte [ax]
     pop [ax+cx]      ; stack --> byte [ax+cx]
     pop [1]          ; stack --> byte [1]
     pop [1+cx]       ; stack --> byte [1+cx]
     pop word [ax]    ; stack --> word [ax]
     pop word [ax+cx] ; stack --> word [ax+cx]
     pop word [1]     ; stack --> word [1]
     pop word [1+cx]  ; stack --> word [1+cx]

    XCHG источник, назначение
    ─────────────────────────────────────────────────────────────────────────
      Эта   команда   позволяет   обменять  значение  источника  на  значение
     назначения,  т.е.  меняет  их  значения  местами. В качестве источника и
     назначения может выступать регистр или адрес в памяти.
      Источник  и  назначение  не  могут быть одновременно адресами в памяти,
     т.е. обмен значений не может происходить между значениями в памяти.
      Если  в  качестве источника или в качестве назначения выступает адрес в
     памяти, то вы должны явным образом указать, сколько байт по этому адресу
     относятся  к  значению.  Для  этого  сразу после команды XCHG, вы должны
     использовать  одно  из  слов  описанных  в  команде MOV. Если в качестве
     источника и назначения выступают регистры, то этого можно не делать.
      Эта   команды   ни  каким  образом  не  влияет  на  флаги  виртуального
     процессора.

    Пример использования команды XCHG:
     xchg ax, bx           ; ax <--> bx
     xchg ax, [bx]         ; ax <--> byte [bx]
     xchg ax, [bx+cx]      ; ax <--> byte [bx+cx]
     xchg ax, [1]          ; ax <--> byte [1]
     xchg ax, [1+cx]       ; ax <--> byte [1+cx]
     xchg [ax], bx         ; byte [ax] <--> bx
     xchg [ax+cx], bx      ; byte [ax+cx] <--> bx
     xchg [1], ax          ; byte [1] <--> ax
     xchg [1+cx], ax       ; byte [1+cx] <--> ax
     xchg word ax, [bx]    ; ax <--> word [bx]
     xchg word ax, [bx+cx] ; ax <--> word [bx+cx]
     xchg word ax, [1]     ; ax <--> word [1]
     xchg word ax, [1+cx]  ; ax <--> word [1+cx]
     xchg word [ax], bx    ; word [ax] <--> bx
     xchg word [ax+cx], bx ; word [ax+cx] <--> bx
     xchg word [1], ax     ; word [1] <--> ax
     xchg word [1+cx], ax  ; word [1+cx] <--> ax


 7. АРИФМЕТИЧЕСКИЕ КОМАНДЫ.
 ────────────────────────────────────────────────────────────────────────────
    Арефметические    команды    предназначены    для    проведения   простых
 арефметических  действий  над значения хранящимися в регистрах или в памяти.
 Далее  идет  список  всех  арефметических  команд  с  их  полным описанием и
 параметрами.

    ADD назначение, источник
    ─────────────────────────────────────────────────────────────────────────
      Эта  команда  выполняет  сложение  двух значений и результат помещает в
     назначение. Значение певого слагаемого берется из назначения, второго -
     из источника.
      В  качестве  источника  могут  выступать  регисры,  числа  и значение в
     памяти.  А  в  качестве  назначения только регистры и значение в памяти.
     Если  в качестве источника или назначения используется значение в памяти
     -   Вы  должны  указать  явным  образом  тип  информации  по  указанному
     адресу(см. MOV)
      При использования этой команды значение источника не меняется.
      Результат  операции  анализируется  и согласно правилам (см. РЕГИСТРЫ и
     ФЛАГИ) изменяются значения нужных флагов.

    Пример использования команды add:
     add ax, bx          ; ax = ax + bx
     add ax, [bx]        ; ax = ax + byte [bx]
     add ax, [bx+cx]     ; ax = ax + byte [bx+cx]
     add ax, 1           ; ax = ax + 1
     add ax, [1]         ; ax = ax + byte [1]
     add ax, [1+bx]      ; ax = ax + byte [1+bx]
     add [ax], bx        ; byte [ax] = byte [ax] + bx
     add [ax], 1         ; byte [ax] = byte [ax] + 1
     add [ax+cx], bx     ; byte [ax+cx] = byte [ax+cx] + bx
     add [ax+cx], 1      ; byte [ax+cx] = byte [ax+cx] + 1
     add [1], ax         ; byte [1] = byte [1] + ax
     add [1], 1          ; byte [1] = byte [1] + 1
     add [1+ax], bx      ; byte [1+ax] = byte [1+ax] + bx
     add [1+ax], 1       ; byte [1+ax] = byte [1+ax] + 1
     add word ax, bx          ; ax = ax + bx
     add word ax, [bx]        ; ax = ax + word [bx]
     add word ax, [bx+cx]     ; ax = ax + word [bx+cx]
     add word ax, 1           ; ax = ax + 1
     add word ax, [1]         ; ax = ax + word [1]
     add word ax, [1+bx]      ; ax = ax + word [1+bx]
     add word [ax], bx        ; word [ax] = word [ax] + bx
     add word [ax], 1         ; word [ax] = word [ax] + 1
     add word [ax+cx], bx     ; word [ax+cx] = word [ax+cx] + bx
     add word [ax+cx], 1      ; word [ax+cx] = word [ax+cx] + 1
     add word [1], ax         ; word [1] = word [1] + ax
     add word [1], 1          ; word [1] = word [1] + 1
     add word [1+ax], bx      ; word [1+ax] = word [1+ax] + bx
     add word [1+ax], 1       ; word [1+ax] = word [1+ax] + 1

    SUB назначение, источник
    ─────────────────────────────────────────────────────────────────────────
      Эта  команда  выполняет  вычитание  двух значений и разность помещает в
     назначение.   Значение  уменьшаемого  берется  из  назначения,  значение
     вычитаемого - из источника.
      В  качестве  источника  могут  выступать  регисры,  числа  и значение в
     памяти.  А  в  качестве  назначения только регистры и значение в памяти.
     Если  в качестве источника или назначения используется значение в памяти
     -   Вы  должны  указать  явным  образом  тип  информации  по  указанному
     адресу(см. MOV)
      При использования этой команды значение источника не меняется.
      Результат  операции  анализируется  и согласно правилам (см. РЕГИСТРЫ и
     ФЛАГИ) изменяются значения нужных флагов.

    Пример использования команды sub:
     sub ax, bx          ; ax = ax - bx
     sub ax, [bx]        ; ax = ax - byte [bx]
     sub ax, [bx+cx]     ; ax = ax - byte [bx+cx]
     sub ax, 1           ; ax = ax - 1
     sub ax, [1]         ; ax = ax - byte [1]
     sub ax, [1+bx]      ; ax = ax - byte [1+bx]
     sub [ax], bx        ; byte [ax] = byte [ax] - bx
     sub [ax], 1         ; byte [ax] = byte [ax] - 1
     sub [ax+cx], bx     ; byte [ax+cx] = byte [ax+cx] - bx
     sub [ax+cx], 1      ; byte [ax+cx] = byte [ax+cx] - 1
     sub [1], ax         ; byte [1] = byte [1] - ax
     sub [1], 1          ; byte [1] = byte [1] - 1
     sub [1+ax], bx      ; byte [1+ax] = byte [1+ax] - bx
     sub [1+ax], 1       ; byte [1+ax] = byte [1+ax] - 1
     sub word ax, bx          ; ax = ax - bx
     sub word ax, [bx]        ; ax = ax - word [bx]
     sub word ax, [bx+cx]     ; ax = ax - word [bx+cx]
     sub word ax, 1           ; ax = ax - 1
     sub word ax, [1]         ; ax = ax - word [1]
     sub word ax, [1+bx]      ; ax = ax - word [1+bx]
     sub word [ax], bx        ; word [ax] = word [ax] - bx
     sub word [ax], 1         ; word [ax] = word [ax] - 1
     sub word [ax+cx], bx     ; word [ax+cx] = word [ax+cx] - bx
     sub word [ax+cx], 1      ; word [ax+cx] = word [ax+cx] - 1
     sub word [1], ax         ; word [1] = word [1] - ax
     sub word [1], 1          ; word [1] = word [1] - 1
     sub word [1+ax], bx      ; word [1+ax] = word [1+ax] - bx
     sub word [1+ax], 1       ; word [1+ax] = word [1+ax] - 1

    MUL назначение, источник
    ─────────────────────────────────────────────────────────────────────────
      Эта команда выполняет умножение двух значений и произведение помещает в
     назначение.  Значение  первого  множителя берется из назначения, второго
     - из источника.
      В  качестве  источника  могут  выступать  регисры,  числа  и значение в
     памяти.  А  в  качестве  назначения только регистры и значение в памяти.
     Если  в качестве источника или назначения используется значение в памяти
     -   Вы  должны  указать  явным  образом  тип  информации  по  указанному
     адресу(см. MOV)
      При использования этой команды значение источника не меняется.
      Результат  операции  анализируется  и согласно правилам (см. РЕГИСТРЫ и
     ФЛАГИ) изменяются значения нужных флагов.

    Пример использования команды mul:
     mul ax, bx          ; ax = ax * bx
     mul ax, [bx]        ; ax = ax * byte [bx]
     mul ax, [bx+cx]     ; ax = ax * byte [bx+cx]
     mul ax, 1           ; ax = ax * 1
     mul ax, [1]         ; ax = ax * byte [1]
     mul ax, [1+bx]      ; ax = ax * byte [1+bx]
     mul [ax], bx        ; byte [ax] = byte [ax] * bx
     mul [ax], 1         ; byte [ax] = byte [ax] * 1
     mul [ax+cx], bx     ; byte [ax+cx] = byte [ax+cx] * bx
     mul [ax+cx], 1      ; byte [ax+cx] = byte [ax+cx] * 1
     mul [1], ax         ; byte [1] = byte [1] * ax
     mul [1], 1          ; byte [1] = byte [1] * 1
     mul [1+ax], bx      ; byte [1+ax] = byte [1+ax] * bx
     mul [1+ax], 1       ; byte [1+ax] = byte [1+ax] * 1
     mul word ax, bx          ; ax = ax * bx
     mul word ax, [bx]        ; ax = ax * word [bx]
     mul word ax, [bx+cx]     ; ax = ax * word [bx+cx]
     mul word ax, 1           ; ax = ax * 1
     mul word ax, [1]         ; ax = ax * word [1]
     mul word ax, [1+bx]      ; ax = ax * word [1+bx]
     mul word [ax], bx        ; word [ax] = word [ax] * bx
     mul word [ax], 1         ; word [ax] = word [ax] * 1
     mul word [ax+cx], bx     ; word [ax+cx] = word [ax+cx] * bx
     mul word [ax+cx], 1      ; word [ax+cx] = word [ax+cx] * 1
     mul word [1], ax         ; word [1] = word [1] * ax
     mul word [1], 1          ; word [1] = word [1] * 1
     mul word [1+ax], bx      ; word [1+ax] = word [1+ax] * bx
     mul word [1+ax], 1       ; word [1+ax] = word [1+ax] * 1

    DIV назначение, источник
    ─────────────────────────────────────────────────────────────────────────
      Эта  команда  выполняет  деление  двух  значений  и  часное  помещает в
     назначение. Значение делимого берется из назначения, значение делителя -
     из источника.
      В  качестве  источника  могут  выступать  регисры,  числа  и значение в
     памяти.  А  в  качестве  назначения только регистры и значение в памяти.
     Если  в качестве источника или назначения используется значение в памяти
     -   Вы  должны  указать  явным  образом  тип  информации  по  указанному
     адресу(см. MOV)
      При использования этой команды значение источника не меняется.
      Результат  операции  анализируется  и согласно правилам (см. РЕГИСТРЫ и
     ФЛАГИ) изменяются значения нужных флагов.

    Пример использования команды div:
     div ax, bx          ; ax = ax / bx
     div ax, [bx]        ; ax = ax / byte [bx]
     div ax, [bx+cx]     ; ax = ax / byte [bx+cx]
     div ax, 1           ; ax = ax / 1
     div ax, [1]         ; ax = ax / byte [1]
     div ax, [1+bx]      ; ax = ax / byte [1+bx]
     div [ax], bx        ; byte [ax] = byte [ax] / bx
     div [ax], 1         ; byte [ax] = byte [ax] / 1
     div [ax+cx], bx     ; byte [ax+cx] = byte [ax+cx] / bx
     div [ax+cx], 1      ; byte [ax+cx] = byte [ax+cx] / 1
     div [1], ax         ; byte [1] = byte [1] / ax
     div [1], 1          ; byte [1] = byte [1] / 1
     div [1+ax], bx      ; byte [1+ax] = byte [1+ax] / bx
     div [1+ax], 1       ; byte [1+ax] = byte [1+ax] / 1
     div word ax, bx          ; ax = ax / bx
     div word ax, [bx]        ; ax = ax / word [bx]
     div word ax, [bx+cx]     ; ax = ax / word [bx+cx]
     div word ax, 1           ; ax = ax / 1
     div word ax, [1]         ; ax = ax / word [1]
     div word ax, [1+bx]      ; ax = ax / word [1+bx]
     div word [ax], bx        ; word [ax] = word [ax] / bx
     div word [ax], 1         ; word [ax] = word [ax] / 1
     div word [ax+cx], bx     ; word [ax+cx] = word [ax+cx] / bx
     div word [ax+cx], 1      ; word [ax+cx] = word [ax+cx] / 1
     div word [1], ax         ; word [1] = word [1] / ax
     div word [1], 1          ; word [1] = word [1] / 1
     div word [1+ax], bx      ; word [1+ax] = word [1+ax] / bx
     div word [1+ax], 1       ; word [1+ax] = word [1+ax] / 1

    INC назначение
    ─────────────────────────────────────────────────────────────────────────
      Эта команда выполняет увеличение назначения на 1.
      В  качестве  назначения  могут  выступать  только регистры и значение в
     памяти.  Если  в качестве назначения используется значение в памяти - Вы
     должны  указать  явным  образом  тип информации по указанному адресу(см.
     MOV)
      Результат  операции  анализируется  и согласно правилам (см. РЕГИСТРЫ и
     ФЛАГИ) изменяются значения нужных флагов.

    Пример использования команды inc:
     inc ax              ; ax = ax + 1
     inc [ax]            ; byte [ax] = byte [ax] + 1
     inc [ax+bx]         ; byte [ax+bx] = byte [ax+bx] + 1
     inc [1]             ; byte [1] = byte [1] + 1
     inc [1+ax]          ; byte [1+ax] = byte [1+ax] + 1
     inc word [ax]       ; word [ax] = word [ax] + 1
     inc word [ax+bx]    ; word [ax+bx] = word [ax+bx] + 1
     inc word [1]        ; word [1] = word [1] + 1
     inc word [1+ax]     ; word [1+ax] = word [1+ax] + 1

    DEC назначение
    ─────────────────────────────────────────────────────────────────────────
      Эта команда выполняет уменьшение назначения на 1.
      В  качестве  назначения  могут  выступать  только регистры и значение в
     памяти.  Если  в качестве назначения используется значение в памяти - Вы
     должны  указать  явным  образом  тип информации по указанному адресу(см.
     MOV)
      Результат  операции  анализируется  и согласно правилам (см. РЕГИСТРЫ и
     ФЛАГИ) изменяются значения нужных флагов.

    Пример использования команды dec:
     dec ax              ; ax = ax - 1
     dec [ax]            ; byte [ax] = byte [ax] - 1
     dec [ax+bx]         ; byte [ax+bx] = byte [ax+bx] - 1
     dec [1]             ; byte [1] = byte [1] - 1
     dec [1+ax]          ; byte [1+ax] = byte [1+ax] - 1
     dec word [ax]       ; word [ax] = word [ax] - 1
     dec word [ax+bx]    ; word [ax+bx] = word [ax+bx] - 1
     dec word [1]        ; word [1] = word [1] - 1
     dec word [1+ax]     ; word [1+ax] = word [1+ax] - 1

    NEG назначение
    ─────────────────────────────────────────────────────────────────────────
      Эта команда меняет знак назначения на противоположный.
      В  качестве  назначения  могут  выступать  только регистры и значение в
     памяти.  Если  в качестве назначения используется значение в памяти - Вы
     должны  указать  явным  образом  тип информации по указанному адресу(см.
     MOV)
      Результат  операции  анализируется  и согласно правилам (см. РЕГИСТРЫ и
     ФЛАГИ) изменяются значения нужных флагов.

    Пример использования команды neg:
     neg ax              ; ax = - ax
     neg [ax]            ; byte [ax] = - byte [ax]
     neg [ax+bx]         ; byte [ax+bx] = - byte [ax+bx]
     neg [1]             ; byte [1] = - byte [1]
     neg [1+ax]          ; byte [1+ax] = - byte [1+ax]
     neg word [ax]       ; word [ax] = - word [ax]
     neg word [ax+bx]    ; word [ax+bx] = - word [ax+bx]
     neg word [1]        ; word [1] = - word [1]
     neg word [1+ax]     ; word [1+ax] = - word [1+ax]


    CMP назначение, источник
    ─────────────────────────────────────────────────────────────────────────
      Эта  команда  выполняет  вычитание двух значений, но разность никуда не
     помещает, а использует для модификации флагов.
      Значение  уменьшаемого берется из назначения, значение вычитаемого - из
     источника.
      В  качестве  источника  могут  выступать  регисры,  числа  и значение в
     памяти.  А  в  качестве  назначения только регистры и значение в памяти.
     Если  в качестве источника или назначения используется значение в памяти
     -   Вы  должны  указать  явным  образом  тип  информации  по  указанному
     адресу(см. MOV)
      При  использования  этой  команды  значение  источника  и назначения не
     меняется.
      Результат  операции  анализируется  и согласно правилам (см. РЕГИСТРЫ и
     ФЛАГИ) изменяются значения нужных флагов.

    Пример использования команды cmp:
     cmp ax, bx          ; ax - bx
     cmp ax, [bx]        ; ax - byte [bx]
     cmp ax, [bx+cx]     ; ax - byte [bx+cx]
     cmp ax, 1           ; ax - 1
     cmp ax, [1]         ; ax - byte [1]
     cmp ax, [1+bx]      ; ax - byte [1+bx]
     cmp [ax], bx        ; byte [ax] - bx
     cmp [ax], 1         ; byte [ax] - 1
     cmp [ax+cx], bx     ; byte [ax+cx] - bx
     cmp [ax+cx], 1      ; byte [ax+cx] - 1
     cmp [1], ax         ; byte [1] - ax
     cmp [1], 1          ; byte [1] - 1
     cmp [1+ax], bx      ; byte [1+ax] - bx
     cmp [1+ax], 1       ; byte [1+ax] - 1
     cmp word ax, bx          ; ax - bx
     cmp word ax, [bx]        ; ax - word [bx]
     cmp word ax, [bx+cx]     ; ax - word [bx+cx]
     cmp word ax, 1           ; ax - 1
     cmp word ax, [1]         ; ax - word [1]
     cmp word ax, [1+bx]      ; ax - word [1+bx]
     cmp word [ax], bx        ; word [ax] - bx
     cmp word [ax], 1         ; word [ax] - 1
     cmp word [ax+cx], bx     ; word [ax+cx] - bx
     cmp word [ax+cx], 1      ; word [ax+cx] - 1
     cmp word [1], ax         ; word [1] - ax
     cmp word [1], 1          ; word [1] - 1
     cmp word [1+ax], bx      ; word [1+ax] - bx
     cmp word [1+ax], 1       ; word [1+ax] - 1


 8. ЛОГИЧЕСКИЕ КОМАНДЫ.
 ────────────────────────────────────────────────────────────────────────────
    Логические   команды  предназначены  для  проведения  простых  логических
 операций  над  значения  хранящимися  в  регистрах  или в памяти. Далее идет
 список всех логических команд с их полным описанием и параметрами.

    AND назначение, источник
    ─────────────────────────────────────────────────────────────────────────
      Эта  команда выполняет действие называемое побитовое И для назначения и
     источника, а результат помещает в назначение.
      В  качестве  источника  могут  выступать  регисры,  числа  и значение в
     памяти.  А  в  качестве  назначения только регистры и значение в памяти.
     Если  в качестве источника или назначения используется значение в памяти
     -   Вы  должны  указать  явным  образом  тип  информации  по  указанному
     адресу(см. MOV)
      При использования этой команды значение источника не меняется.
      Результат  операции  анализируется  и согласно правилам (см. РЕГИСТРЫ и
     ФЛАГИ) изменяются значения нужных флагов.

    Пример использования команды and:
     and ax, bx          ; ax = ax & bx
     and ax, [bx]        ; ax = ax & byte [bx]
     and ax, [bx+cx]     ; ax = ax & byte [bx+cx]
     and ax, 1           ; ax = ax & 1
     and ax, [1]         ; ax = ax & byte [1]
     and ax, [1+bx]      ; ax = ax & byte [1+bx]
     and [ax], bx        ; byte [ax] = byte [ax] & bx
     and [ax], 1         ; byte [ax] = byte [ax] & 1
     and [ax+cx], bx     ; byte [ax+cx] = byte [ax+cx] & bx
     and [ax+cx], 1      ; byte [ax+cx] = byte [ax+cx] & 1
     and [1], ax         ; byte [1] = byte [1] & ax
     and [1], 1          ; byte [1] = byte [1] & 1
     and [1+ax], bx      ; byte [1+ax] = byte [1+ax] & bx
     and [1+ax], 1       ; byte [1+ax] = byte [1+ax] & 1
     and word ax, bx          ; ax = ax & bx
     and word ax, [bx]        ; ax = ax & word [bx]
     and word ax, [bx+cx]     ; ax = ax & word [bx+cx]
     and word ax, 1           ; ax = ax & 1
     and word ax, [1]         ; ax = ax & word [1]
     and word ax, [1+bx]      ; ax = ax & word [1+bx]
     and word [ax], bx        ; word [ax] = word [ax] & bx
     and word [ax], 1         ; word [ax] = word [ax] & 1
     and word [ax+cx], bx     ; word [ax+cx] = word [ax+cx] & bx
     and word [ax+cx], 1      ; word [ax+cx] = word [ax+cx] & 1
     and word [1], ax         ; word [1] = word [1] & ax
     and word [1], 1          ; word [1] = word [1] & 1
     and word [1+ax], bx      ; word [1+ax] = word [1+ax] & bx
     and word [1+ax], 1       ; word [1+ax] = word [1+ax] & 1

    OR назначение, источник
    ─────────────────────────────────────────────────────────────────────────
      Эта  команда выполняет действие называемое побитовое ИЛИ для назначения
     и источника, а результат помещает в назначение.
      В  качестве  источника  могут  выступать  регисры,  числа  и значение в
     памяти.  А  в  качестве  назначения только регистры и значение в памяти.
     Если  в качестве источника или назначения используется значение в памяти
     -   Вы  должны  указать  явным  образом  тип  информации  по  указанному
     адресу(см. MOV)
      При использования этой команды значение источника не меняется.
      Результат  операции  анализируется  и согласно правилам (см. РЕГИСТРЫ и
     ФЛАГИ) изменяются значения нужных флагов.

    Пример использования команды or:
     or ax, bx           ; ax = ax | bx
     or ax, [bx]         ; ax = ax | byte [bx]
     or ax, [bx+cx]      ; ax = ax | byte [bx+cx]
     or ax, 1            ; ax = ax | 1
     or ax, [1]          ; ax = ax | byte [1]
     or ax, [1+bx]       ; ax = ax | byte [1+bx]
     or [ax], bx         ; byte [ax] = byte [ax] | bx
     or [ax], 1          ; byte [ax] = byte [ax] | 1
     or [ax+cx], bx      ; byte [ax+cx] = byte [ax+cx] | bx
     or [ax+cx], 1       ; byte [ax+cx] = byte [ax+cx] | 1
     or [1], ax          ; byte [1] = byte [1] | ax
     or [1], 1           ; byte [1] = byte [1] | 1
     or [1+ax], bx       ; byte [1+ax] = byte [1+ax] | bx
     or [1+ax], 1        ; byte [1+ax] = byte [1+ax] | 1
     or word ax, bx           ; ax = ax | bx
     or word ax, [bx]         ; ax = ax | word [bx]
     or word ax, [bx+cx]      ; ax = ax | word [bx+cx]
     or word ax, 1            ; ax = ax | 1
     or word ax, [1]          ; ax = ax | word [1]
     or word ax, [1+bx]       ; ax = ax | word [1+bx]
     or word [ax], bx         ; word [ax] = word [ax] | bx
     or word [ax], 1          ; word [ax] = word [ax] | 1
     or word [ax+cx], bx      ; word [ax+cx] = word [ax+cx] | bx
     or word [ax+cx], 1       ; word [ax+cx] = word [ax+cx] | 1
     or word [1], ax          ; word [1] = word [1] | ax
     or word [1], 1           ; word [1] = word [1] | 1
     or word [1+ax], bx       ; word [1+ax] = word [1+ax] | bx
     or word [1+ax], 1        ; word [1+ax] = word [1+ax] | 1

    XOR назначение, источник
    ─────────────────────────────────────────────────────────────────────────
      Эта команда выполняет действие называемое побитовое исключающее ИЛИ для
     назначения и источника, а результат помещает в назначение.
      В  качестве  источника  могут  выступать  регисры,  числа  и значение в
     памяти.  А  в  качестве  назначения только регистры и значение в памяти.
     Если  в качестве источника или назначения используется значение в памяти
     -   Вы  должны  указать  явным  образом  тип  информации  по  указанному
     адресу(см. MOV)
      При использования этой команды значение источника не меняется.
      Результат  операции  анализируется  и согласно правилам (см. РЕГИСТРЫ и
     ФЛАГИ) изменяются значения нужных флагов.

    Пример использования команды xor:
     xor ax, bx          ; ax = ax ^ bx
     xor ax, [bx]        ; ax = ax ^ byte [bx]
     xor ax, [bx+cx]     ; ax = ax ^ byte [bx+cx]
     xor ax, 1           ; ax = ax ^ 1
     xor ax, [1]         ; ax = ax ^ byte [1]
     xor ax, [1+bx]      ; ax = ax ^ byte [1+bx]
     xor [ax], bx        ; byte [ax] = byte [ax] ^ bx
     xor [ax], 1         ; byte [ax] = byte [ax] ^ 1
     xor [ax+cx], bx     ; byte [ax+cx] = byte [ax+cx] ^ bx
     xor [ax+cx], 1      ; byte [ax+cx] = byte [ax+cx] ^ 1
     xor [1], ax         ; byte [1] = byte [1] ^ ax
     xor [1], 1          ; byte [1] = byte [1] ^ 1
     xor [1+ax], bx      ; byte [1+ax] = byte [1+ax] ^ bx
     xor [1+ax], 1       ; byte [1+ax] = byte [1+ax] ^ 1
     xor word ax, bx          ; ax = ax ^ bx
     xor word ax, [bx]        ; ax = ax ^ word [bx]
     xor word ax, [bx+cx]     ; ax = ax ^ word [bx+cx]
     xor word ax, 1           ; ax = ax ^ 1
     xor word ax, [1]         ; ax = ax ^ word [1]
     xor word ax, [1+bx]      ; ax = ax ^ word [1+bx]
     xor word [ax], bx        ; word [ax] = word [ax] ^ bx
     xor word [ax], 1         ; word [ax] = word [ax] ^ 1
     xor word [ax+cx], bx     ; word [ax+cx] = word [ax+cx] ^ bx
     xor word [ax+cx], 1      ; word [ax+cx] = word [ax+cx] ^ 1
     xor word [1], ax         ; word [1] = word [1] ^ ax
     xor word [1], 1          ; word [1] = word [1] ^ 1
     xor word [1+ax], bx      ; word [1+ax] = word [1+ax] ^ bx
     xor word [1+ax], 1       ; word [1+ax] = word [1+ax] ^ 1

    NOT назначение
    ─────────────────────────────────────────────────────────────────────────
      Эта команда выполняет действие называемое побитовое НЕТ для назначения.
      В  качестве  назначения  могут  выступать  только регистры и значение в
     памяти.  Если  в качестве назначения используется значение в памяти - Вы
     должны  указать  явным  образом  тип информации по указанному адресу(см.
     MOV)
      Результат  операции  анализируется  и согласно правилам (см. РЕГИСТРЫ и
     ФЛАГИ) изменяются значения нужных флагов.

    Пример использования команды not:
     not ax              ; ax = not ax
     not [ax]            ; byte [ax] = not byte [ax]
     not [ax+bx]         ; byte [ax+bx] = not byte [ax+bx]
     not [1]             ; byte [1] = not byte [1]
     not [1+ax]          ; byte [1+ax] = not byte [1+ax]
     not word [ax]       ; word [ax] = not word [ax]
     not word [ax+bx]    ; word [ax+bx] = not word [ax+bx]
     not word [1]        ; word [1] = not word [1]
     not word [1+ax]     ; word [1+ax] = not word [1+ax]

    TEST назначение, источник
    ─────────────────────────────────────────────────────────────────────────
      Эта  команда выполняет действие называемое побитовое И для назначения и
     источника, но результат использует для модификации флагов.
      В  качестве  источника  могут  выступать  регисры,  числа  и значение в
     памяти.  А  в  качестве  назначения только регистры и значение в памяти.
     Если  в качестве источника или назначения используется значение в памяти
     -   Вы  должны  указать  явным  образом  тип  информации  по  указанному
     адресу(см. MOV)
      При  использования  этой  команды  значение  источника  и назначения не
     меняется.
      Результат  операции  анализируется  и согласно правилам (см. РЕГИСТРЫ и
     ФЛАГИ) изменяются значения нужных флагов.

    Пример использования команды test:
     test ax, bx          ; ax & bx
     test ax, [bx]        ; ax & byte [bx]
     test ax, [bx+cx]     ; ax & byte [bx+cx]
     test ax, 1           ; ax & 1
     test ax, [1]         ; ax & byte [1]
     test ax, [1+bx]      ; ax & byte [1+bx]
     test [ax], bx        ; byte [ax] & bx
     test [ax], 1         ; byte [ax] & 1
     test [ax+cx], bx     ; byte [ax+cx] & bx
     test [ax+cx], 1      ; byte [ax+cx] & 1
     test [1], ax         ; byte [1] & ax
     test [1], 1          ; byte [1] & 1
     test [1+ax], bx      ; byte [1+ax] & bx
     test [1+ax], 1       ; byte [1+ax] & 1
     test word ax, bx          ; ax & bx
     test word ax, [bx]        ; ax & word [bx]
     test word ax, [bx+cx]     ; ax & word [bx+cx]
     test word ax, 1           ; ax & 1
     test word ax, [1]         ; ax & word [1]
     test word ax, [1+bx]      ; ax & word [1+bx]
     test word [ax], bx        ; word [ax] & bx
     test word [ax], 1         ; word [ax] & 1
     test word [ax+cx], bx     ; word [ax+cx] & bx
     test word [ax+cx], 1      ; word [ax+cx] & 1
     test word [1], ax         ; word [1] & ax
     test word [1], 1          ; word [1] & 1
     test word [1+ax], bx      ; word [1+ax] & bx
     test word [1+ax], 1       ; word [1+ax] & 1


 9. КОМАНДЫ УПРАВЛЕНИЯ ПОТОКОМ.
 ────────────────────────────────────────────────────────────────────────────
    Команды  управления  потоком  можно  разделить  на  две  части  - команды
 условного  изменения  потока  и  команды  безусловного изменения потока. Это
 означает,   что   имеются   команды,   которые  изменяют  последовательность
 выполнения  программы  всегда  одинаково,  а  есть команды, которые изменяют
 последовательность, только при определенных условиях(значениях флагов).
    Кроме   того,  еще  есть  команды,  которые  изменяют  последовательность
 выполнения,  с  дальнейшей  возможность  вернуться к адресу памяти, где была
 встречена такая команда.
    Так  же,  имеется  команда,  которая  отличается от всех других, тем, что
 позволяет  временно передать управление ядру виртуальной машины, для решения
 какой-то  сложной  задачи  или  для  взаимодействия  с  каким-то компонентом
 виртуальной  машины.  Далее  идет список всех команд управления потоком с их
 полным описанием и параметрами.

    CALL адрес
    ─────────────────────────────────────────────────────────────────────────
      Эта  команда делает следующие действия: помещает в стек адрес следующей
     команды, а в регистр LIP помещает адрес, указанный в качестве параметра.
      В качестве адреса может выступать число или регистр.
      При использование этой команды значение адреса не меняется.

    Пример использования команды call:
     call 0              ; push LIP   mov LIP, 0
     call ax             ; push LIP   mov LIP, ax
     call 0+ax           ; push LIP   mov LIP, 0   add LIP, ax
     call ax+bx          ; push LIP   mov LIP, ax  add LIP, bx

    JMP адрес
    ─────────────────────────────────────────────────────────────────────────
      Эта  команда  помещает  в  регистр  LIP  адрес,  указанный  в  качестве
     параметра.
      В качестве адреса может выступать число или регистр.
      При использование этой команды значение адреса не меняется.

    Пример использования команды jmp:
     jmp 0               ; mov LIP, 0
     jmp ax              ; mov LIP, ax
     jmp 0+ax            ; mov LIP, 0   add LIP, ax
     jmp ax+bx           ; mov LIP, ax  add LIP, bx

    RET
    ─────────────────────────────────────────────────────────────────────────
      Эта  команда  помещает  в регистр LIP восьмибайтовое число хранящееся в
     вершине  стека.  С помощью этой команды можно вернуться к тому месту где
     последний  раз  встретилась  команда  call,  так как она помещает в стек
     адрес следующей команды.

    Пример использования команды ret:
     ret                 ; mov qword LIP, [LSP]

    CSP назначение
    ─────────────────────────────────────────────────────────────────────────
      Эта  команда  временно  передает  управление  функции  ядра  с  номером
     назначение.  С  помощью  этой  команды  осуществляется  доступ  ко  всем
     компонентам виртуальной машины.
      В качестве назначения может выступать регистр или число.
      При использовании этой команды значение назначения не меняется.
      При  использовании  этой  команды значения регистра LIP не меняется, но
     меняются значения других регистров, в зависомости от вызванной функции.

    Пример использования команды csp:
     csp 0               ; передать управление функции ядра с номером 0
     csp ax              ; передать управление функции ядра с номером
                         ; хранящимся в регистре ax

    JRZ регистр, адрес
    ─────────────────────────────────────────────────────────────────────────
      Эта  команда  помещает  в  регистр  LIP  адрес,  указанный  в  качестве
     параметра  тогда  и только тогда, когда значение регистра, переданного в
     качестве параметра, равно 0.
      В качестве адреса может выступать число или регистр.
      При использование этой команды значение адреса и регистра не меняется.

    Пример использования команды jrz:
     jrz ax, 0           ; если ax = 0 то mov LIP, 0
     jrz ax, bx          ; если ax = 0 то mov LIP, bx
     jrz ax, 0+bx        ; если ax = 0 то { mov LIP, 0   add LIP, bx }
     jrz ax, bx+cx       ; если ax = 0 то ( mov LIP, bx  add LIP, cx }

    JRNZ регистр, адрес
    ─────────────────────────────────────────────────────────────────────────
      Эта  команда  помещает  в  регистр  LIP  адрес,  указанный  в  качестве
     параметра  тогда  и только тогда, когда значение регистра, переданного в
     качестве параметра, не равно 0.
      В качестве адреса может выступать число или регистр.
      При использование этой команды значение адреса и регистра не меняется.

    Пример использования команды jrnz:
     jrnz ax, 0          ; если ax <> 0 то mov LIP, 0
     jrnz ax, bx         ; если ax <> 0 то mov LIP, bx
     jrnz ax, 0+bx       ; если ax <> 0 то { mov LIP, 0   add LIP, bx }
     jrnz ax, bx+cx      ; если ax <> 0 то ( mov LIP, bx  add LIP, cx }

    J<условие> адрес
    ─────────────────────────────────────────────────────────────────────────
      Эта  команда  помещает  в  регистр  LIP  адрес,  указанный  в  качестве
     параметра  тогда и только тогда, когда флаг указанный в качестве условия
     равен 1 или если в качестве условия указанна буква G, L или E, то тогда,
     если  результат  математической  или  логической операции больше, меньше
     или равен 0, соответственно.
      В качестве адреса может выступать число или регистр.
      В  качестве условия может выступать буква названия флага или G,L,E, как
     написано выше.
      При использование этой команды значение адреса и регистра не меняется.

    Пример использования команды j<условие>:
     jo 0                ; если флаг O = 1 то mov LIP, 0
     jc ax               ; если флаг C = 1 то mov LIP, ax
     je 0+ax             ; если резул. операции = 0 то mov LIP, 0  add LIP,ax
     ja ax+bx            ; если флаг A = 1 то mov LIP, ax  add LIP, bx

    JN<условие> адрес
    ─────────────────────────────────────────────────────────────────────────
      Эта  команда  помещает  в  регистр  LIP  адрес,  указанный  в  качестве
     параметра  тогда и только тогда, когда флаг указанный в качестве условия
     равен 0 или если в качестве условия указанна буква G, L или E, то тогда,
     если результат математической или логической операции небольше, неменьше
     или неравен 0, соответственно.
      В качестве адреса может выступать число или регистр.
      В  качестве условия может выступать буква названия флага или G,L,E, как
     написано выше.
      При использование этой команды значение адреса и регистра не меняется.

    Пример использования команды jn<условие>:
     jno 0               ; если флаг O = 0 то mov LIP, 0
     jnc ax              ; если флаг C = 0 то mov LIP, ax
     jne 0+ax            ; если резул. операции <> 0 то mov LIP, 0  add LIP,ax
     jna ax+bx           ; если флаг A = 0 то mov LIP, ax  add LIP, bx


 10. КОМАНДЫ УПРАВЛЕНИЯ ВИРТУАЛЬНЫМ ПРОЦЕССОРОМ
 ────────────────────────────────────────────────────────────────────────────
    Команды   этой  группы  предназначенны  для  изменения  состояния  работы
 процессора,  а  именно,  для  модификации флагов. Кроме того к командам этой
 группы  я  отнес  пустую  операцию,  так  как  она  изменяет только значение
 регистра  LIP,  что  соответствует назначению этой группы. Далее идет список
 всех  команд  управления  виртуальным  процессором  с  их полным описанием и
 параметрами.

    CL<флаг>
    ─────────────────────────────────────────────────────────────────────────
      Эта команда помещает в указанный флаг 0.
      В качестве условия может выступать буква названия флага.

    Пример использования команды cl<флаг>:
     clo                 ; флаг O = 0
     cls                 ; флаг S = 0
     clz                 ; флаг Z = 0
     cla                 ; флаг A = 0

    ST<флаг>
    ─────────────────────────────────────────────────────────────────────────
      Эта команда помещает в указанный флаг 1.
      В качестве условия может выступать буква названия флага.

    Пример использования команды st<флаг>:
     sto                 ; флаг O = 1
     sts                 ; флаг S = 1
     stz                 ; флаг Z = 1
     sta                 ; флаг A = 1

    NOP
    ─────────────────────────────────────────────────────────────────────────
      Эта команда трактуется как пустая операция. Когда виртуальный процессор
     встречает  эту  команду,  он просто увеличивает значение регистра LIP на
     размер этой команды.

    Пример использования команды nop:
     nop                 ; add LIP, SizeOf(nop)



 Автор программы:          Штокало Алексей Геннадиевич
 Адрес домашней странички: www.shag.itgo.com
 E-mail:                   shag@qnx.com
 ────────────────────────────────────────────────────────────────────────────