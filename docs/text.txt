  Поток  -  это  источник или получатель данных; его можно связать с диском
или с каким-то другим внешним устройством.

1. Введение.

  В  наше  время  происходит  бурное  развитие  техники.  То,  что  сегодня
считается  пределом  мечтаний  - завтра обыденная вещь. Такой стремительный
прогресс   в   програмировании  и  компьютерной  технике  может  привести к
следующим последствиям:
  1.  Программы  отлично  работающие  сегодня  могут  работать с ошибками в
будущемм.  Например,  я  могу  привести  известный  факт.  Если  Вы  пишете
программу  на  Турбо  Паскале  и  используете  модуль Crt (который входит в
состав  всего  программного  комплекса) Вы получите такой эффект: программа
отлично  работающая  на  компьютерах  с частотой ниже 300 мГц выдает ошибку
деления на ноль на компьютерах с большей частотой.
  2.  Такая  возможность,  как  появления новых устройств, которые вытеснят
существующие  сейчас,  существовала всегда. Если это произойдет - программы
работающие   с   старыми   устройствами   -   окажутся   непригодными   для
использования.  В  качестве  примера  можно  привести  такой  факт:  первые
компьютеры  использовали  в  качестве носителей информации магнитофоны и им
подобные  устройства. Такое положение дел сохранялось достаточно длительное
время.  За этот период появилось большое количество программ, расчитаных на
работу  с  магнитофонами.  Но  появились  новые  носители  - дисководы. Они
отличались  быстротой,  удобством  и  качеством.  Естественное  следствие -
магнитофоны  ушли  из  жизни.  Это  привело  к  потери  большого количества
программного обеспечения, которое стоит очень дорого.
  3.  Еще  одна  из проблем - обратная несовместимость. Все больше и больше
программ  требуют  специальные  устройства,  в  часности  видеокарты. Такое
положение  дел  заставляет пользователей очень часто обновлять конфигурацию
своего компьютера, что очень накладно. Таким образом, эта проблема приводит
к уменьшению числа пользователей новым программным обеспечением.

  На   сегодняшний  день  существует  несколько  способов  борьбы  с  этими
проблемами.  Самы  простой  из  них - драйвера устройств. Но этот способ не
устраняет  первую  проблему  (см.  више  проблему  под номером 1). Еще один
способ  -  виртуальные  устройства,  который  удовлетворяет  большей  части
требований.
  Эти  проблемы  меня  сильно заинтересовали, так как от их решения зависит
многое в дальнейшем развитии программирования.
  В  своей  работе  я  попытался  реализовать свое собственное решение этих
проблем.

2. Мое решение.
  За основу решения, я взял один из приведенных выше способов - виртуальные
устройства.  По  сути,  виртуальное  устройство  -  это  драйвер, который с
помощью  того,  что есть в компьютере эмулирует отсутствующее устройство. В
этой  работе я расширел пределы эмулируемых устройств - я попытался сделать
эмулятор  полноценного  компьютера  (далее эмулируемый компьютер называется
виртуальной машиной).
  Такое решение я принял после более глубокого изучения проблемы. Например,
всегда  можно  эмулировать  какое-то  устройство,  а программа использующая
такое  устройство  будет  работать  без ошибок, даже при его отсутствии. Но
если вдуматься в проблему (см. више проблему под номером 2), то получается,
что   может   появится  новый  процессор,  который  будет  отличен  от  уже
существующих. Такой поворот дел, наводит на следующие мысли - надо написать
эмулятор  процессора.  Такая работа очень сложна и неоправдана, потому что,
всегда  есть вероятность, что появится не один новый процессор а несколько.
Писать  эмуляторы  для  каждого  из  них  -  нерационально.  Гораздо  проще
разработать  новый процессор и потом писать только его эмулятор для каждого
нового   типа   компьютеров.  Я  избрал  именно  этот  способ,  но  немного
модернезировал  его, потому, что я решил емулировать не только процессор, а
и   все   остальные   устройства,  которые  входят  в  состав  полноценного
компьютера.  Ниже  приведена  схема взаимодействия компонентов компьютера c
виртуальной  машиной  и  программой  работающей под управлением виртуальной
машины.

  ┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐
    Настоящий компьютер                        Виртуальная машина
  │                                         ││                             │
    ┌──────────────────────────────────────┐                    ┌─────────┐
  │ │ Виртуальные устройства               │││                  │ Програм-││
    └─────────────────┬──────────────────┬─┘                    │ ма рабо-│
  │ ┌────────────┐   │   ┌───────────┐ │  ││                  │ тающая  ││
    │ Настоящие  ├─┘  │   │ Ядро      ├┘ │                      │ под уп- │
  │ │ устройства │───┘   │ эмулятора │  │  ││                  │ равлени-││
    │            │        │           │─┘     ┌─────────────┐  │ ем VM   │
  │ └────────────┘─┐     │           │     ││ │             ├─│         ││
    ┌────────────┐─┘     │           │        │ Виртуальный │  └┬────┬───┘
  │ │ Настоящий  ├───────│           ├───────│ процессор   │──┘   │    │
    │ процессор  │        │           │     ││ │             │      │ │
  │ │            │───────┤           │───────┤             │──┐  │     │
    └────────────┘─┐     │           │        │             │  ┌┴──┴─────┐
  │ ┌────────────┐─┘     │           │     ││ │             ├─│ Память, ││
    │ Настоящая  │        │           │─┐     └─────────────┘  │ выделен-│
  │ │ память     │───┐   │           │  │  ││                  │ ная для ││
    │            ├─┐  │   │           ├┐ │                      │ работаю-│
  │ └────────────┘   │   └───────────┘ │  ││                  │ щей про-││
    ┌─────────────────┴──────────────────┴─┐                    │ граммы  │
  │ │ Виртуальная память                   │││                  │         ││
    └──────────────────────────────────────┘                    └─────────┘
  └ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘└ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘

  Я разработал эту схему исходя из нескольких принципов:
  1.  Программа  работающая  под  управлением  виртуальной машины не должна
иметь  доступа  к  настоящему  компьютеру.  Это  сделанно  с целью защитить
систему от вирусов и разрущения памяти;
  2.  Эмулятор  не  должен  работать  напрямую с компонентами компьютера. Я
разрабатывал  эмулятор  так,  чтобы  он  без изменений мог быть перенесен в
другую систему или на другую платформу.

  Такая  схема  взаимодействия позволяет легко совершенствовать и добавлять
новые  устройства  без  модификации  программ  для  виртуальной машины. Это
открывает большие перспективы по интеграции этой виртуальной машины в любые
программно-вычислительные  комплексы  и  оптимизации для решения конкретных
задач.   При   этом   не  будет  теряться  совместимость  с  первоначальным
вариантом виртуально машины.
  Вообще,  под  виртуальную машину можно писать программы для разных целей,
потому,  что  она  дает  мощные  средства  взаимодействия  с устройствами и
памятью,  а  также дает полную гарантию работоспособности на любой технике,
что  немаловажно  в  наше  время,  когда  каждые  полгода,  а  то и меньше,
появляются новые процессоры, графические карты и другие компоненты.

3. Пакет разработчика.
  Разрабатывая  свои  программы я учитывал проблему обратной совместимости,
поэтому  все  мои  программы имеют низкие технические требования. Так как в
пакете  разработчика  не  одна  программа, то технические требования каждой
программы представленны в таблице, которая следует далее.
┌──────────┬─────────┬───────────┬────────────┬────────────┬─────┬──────┬───┐
│Программа │Процессор│Сопроцессор│Свободная   │Свободное   │Видео│Мышь  │OS │
│          │         │           │оперативная │место на    │карта│      │   │
│          │         │           │память      │диске       │     │      │   │
├──────────┼─────────┼───────────┼────────────┼────────────┼─────┼──────┼───┤
│компилятор│ 286     │ 287       │160 килобайт│1 мегабайт  │CGA  │ненадо│DOS│
│эмулятор  │ 286     │ 287       │260 килобайт│0.5 мегабайт│VGA  │надо  │DOS│
│дебуггер  │ 286     │ 287       │290 килобайт│0.5 мегабайт│VGA  │надо  │DOS│
│IDE       │ 286     │ ненадо    │520 килобайт│1 мегабайт  │CGA  │надо  │DOS│
│эмулятор  │ 286     │ ненадо    │15  килобайт│ненадо      │CGA  │ненадо│DOS│
│мыши      │         │           │            │            │     │      │   │
└──────────┴─────────┴───────────┴────────────┴────────────┴─────┴──────┴───┘
  Все  программы,  которые входят в этот пакет, были написанны мной в Турбо
Паскале  версии  7.0  и  Турбо Ассемблере версии 4.0. Почему я выбрал Турбо
Ассемблер  надеюсь  понятно  (самый  быстрый  и  полный доступ ко всему что
надо),  а выбор Турбо Паскаля могу обосновать. Я уже 4 года пишу на Паскале
и  всего  2  года  на  Си и пришел к выводу, что на Турбо Паскале программы
получаются не хуже чем на Си, а все недостатки программ на Паскале - это от
"кривых рук" программистов, которые их пишут.
  При  написании этих программ мною были использванны всего два стандартных
модуля из поставки Турбо Паскаля - это DOS и CRT.
  Для   реализации   всех  остальных  функций  мне  пришлось  разрабатывать
собственные модули.
  В  часности, для работы с графикой я написал свой модуль. Это объясняется
тем,  что  стандартный  модуль  Graph  не  позволяет работать с 24-х битным
цветом,  что  является  стандартом  для моей виртуальной машины. Я взял VGA
видеокарту  как минимальную конфигурацию, только по той причине, что в моем
графическом  модуле  реализованна  технология  dithering, поэтому даже в 16
цветах,  можно эмулировать 24-х битную графику. Я мог бы снизить требования
к  видеокарте  до  CGA  или  EGA,  но  проведя  исследование  в работе этой
технологии  в  2-х  цветном  и  16-и  цветном  режиме  (на  VGA  я загружаю
специальную  палитру цветов, а на EGA, такая возможность отсутствует) решил
отказаться  от  этой идее, так как результаты были не очень красивы, хотя и
приемлемы.
  В  виртуальной  машине есть возможность работы с векторными шрифтами, но,
так  как,  я  не использую стандартную библиотку для работы с графикой, мне
пришлось  писать  собственный модуль, который реализует функции по работе с
векторными шрифтами. В качестве векторных шрифтов я взял формат стандартных
CHR  шрифтов,  которые  используются  в  программных пакетах Турбо Паскаль,
Турбо Си.
  Если  Вы  внимательно  изучили  схему взаимодействия виртуальной машины с
компьютером,  то  Вы,  наверное, заметили, что там присутствует виртуальная
память. Если Вы разбираетесь в программировании, то Вы наверное знаете, что
на  процессоре  Intel80x286,  который  является  минимальной конфигурацией,
отсутствует  аппаратная  поддержка виртуальной памяти. Поэтому мне пришлось
писать   собственный  модуль  для  эмуляции  работы  виртуальной  памяти. В
результате  модуль позволяет использовать 64-х битное адресное пространство
при  1  мегабайте  настоящей  памяти.  Это достигается путем создания файла
подкачки  на  жестком  диске  и  его использования в качестве памяти. Такой
подход  достаточно  сильно тормозит работу, но дает вигрыш в памяти даже на
286   компьютере.   В  часности,  я  провел  исследование  скорости  работы
виртуальной  памяти  по отношению к оперативной и получил такие результаты:
виртуальная  память  работает  в  среднем  3-6  раз медленее оперативной, в
случае   использования  жесткого  диска  Seagate  на  252  мегабайта  (тест
проводился  на компьютере c процессором 286 на 16 мегагерц, на более мощных
компьютерах и жестких дисках этот паказатель уменьшается).
  Так  как  эмулятор  должен  работать  везде, а мышка является стандартным
устройством  в  виртуальной  машине,  то  я  решил написать эмулятор мыши и
выделить  его  отдельно  в  виде  драйвера.  Таким образом, если у Вас есть
устройство   типа   мышь,   Вы   можете  использовать  стандартный  драйвер
производителя  Вашей  мыши.  Если у Вас нет мыши, Вы можете испльзовать мой
драйвер,  который поставляется вместе с пакетом разработчика. Этот эмулятор
загружается  в память и работает как обыкновенный драйвер мыши. Поэтому, Вы
можете  использовать  его и для других программ. В дистрибутиве пакета есть
файл  содержащий  полную  документацию  по  этому драйверу с описанием всех
функций и возможностей.
  Так  как  сейчас  распространяется очень много вирусов, я решил, что если
защищу свои программы от вирусов, то сделаю Вам большое одолжение и избавлю
от   головной   боли.   Поэтому  я  разработал  специальную  программу  (на
ассемблере)  которая  интегрируется  в  уже  готовый исполняемый EXE-файл и
защищает  его  от  вирусов.  Например,  если  у Вас появится вирус, а Вы не
будетет  знать  этого,  то,  когда вирус заразит один из исполняемых файлов
пакета, встроенный антивирус сообщит Вам о заражении и предложит вылечиться
(если это возможно).
  Так как моя работа состоит из нескольких исполняемых программ. Каждая из
которых является совершенно самостоятельной, то я опишу реализацию всех
программ коротко.
 а)Компилятор.
  Компилятор  предназначен  для  работы  из  командной  строки.  В качестве
входных  параметров  он може получать имя файла, путь к библиотекам, путь к
картам  памяти,  путь  к  результатам  и  другие  параметры,  которые можно
задавать  как  отдельно,  так  и  все  вместе. Кроме того, компилятор имеет
конфигурационный  файл  имеющий  такую-же  структуру,  как  и  INI  файлы в
операционной системе WINDOWS. Этот конфигурационный файл содержит подробный
коментарий  к  каждому  пункту,  поэтому Вы можете прочитав этот коментарий
установить все настройки так, как Вам того надо.
  Для  работы  компилятора  надо всего 160 килобайт оперативной памяти. Это
связанно с тем, что компилятор использует виртуальную память. На самом деле
он использует приблезительно 800 килобайт виртуальной памяти, так как много
памяти  надо  для  хранения имен и адресов (размер имени может быть от 1 до
255 символов, а адреса занимают по 8 байт каждый).
  Весь  компилятор  построен  в  виде  модуля.  Поэтому можно писать разные
программы  по  работе  с  виртуальной машиной, а подключив к программе этот
модуль  -  встроить  уже  готовый  компилятор  и  использовать  его  вместо
внешнего. Текст модуля содержит обширные коментарии по его использованию, а
в качестве примера я написал
  Ниже представлена общая блочная схема компилятора:
   ┌───────────┐
   │     1     │
   └─────┬─────┘
         
   ┌───────────┐Да      ┌──────────────────────┐
   │     2     ├───────│          3           │─────┐
   └──┬────────┘        └──────────┬───────────┘      │
      │Нет                                           │
      │ ┌─────────────┐ ┌──────────────────────┐Нет   │
      │ │      7      │ │          4           ├─────│
      │ └────┬────────┘ └──────────┬───────────┘      │
                                 Да               │
   ┌───────────┐  │     ┌──────────────────────┐      │
   │     8     │  │     │          5           │      │
   └───────────┘  │     └──────────┬───────────┘      │
                  │                                  │
                  │  Да ┌──────────────────────┐ Нет  │
                  └─────┤          6           ├──────┘
                        └──────────────────────┘
   1 - проверяем наличие компилируемого файла и настраиваем компилятор для
       работы
   2 - проверяем все ли настройки выполнены верно
   3 - получаем очередную строку из файла, корректируем её (удаляем коментарии,
       приводим символы команд, регистров, имен к большим, выводим сообщения)
   4 - проводим лексический анализ строки (сначало на правильность команд,
       затем проверяем имена и числа)
   5 - генерируем код для очередной команды
   6 - проверяем на конец файла и другие ошибки
   7 - если ошибок небыло, то собираем, настраиваем и корректируем весь код
       сгенерированный до этого момента, а затем формируем исполняемый файл.
       Также формаируем вспомогательные файлы(карта памяти, сообщения)
   8 - выводим соответствующее сообщение о окночании работы

  б)Эмулятор.
  Эмулятор  также  предназначен  для работы из командной строки. В качестве
параметров  ему  допускается  передавать только имя исполняемого файла. Все
остальные  настройки  можно  произвести  в  конфигурационном файле, который
аналогичен  по  своему  виду  конфигурационному  файлу компилятора. Почитав
коментарий  к  нему  Вы  без  труда разберетесь в этих настройках. Эмулятор
также  использует виртуальную память для работы. При написании эмулятора, в
блоке  анализирующем  команды не использованно ни одного оператора проверки
условия  (ни IF, ни CASE, ни CMP), так как я использовал метод безусловного
выбора,   который  придумал  сам  после  анализа  метода  сортировки  путем
вычесления  адреса [1,107]. Так как виртуальный процессор - 64-х битный, то
для  генерирования  случайных чисел я использовал метод описанный в разделе
3.2.1  "Исскуство  программирования"  Дональда Кнута (в качестве начального
значения  берется  число хранящееся по адресу $0000:$046C, которое содержит
количество 55-и милисикундных интервалов прошедших с начала дня).
  Эмулятор  состоит  из  модулей.  Каждый  модуль  содержит  в  себе группу
однотипных  команд.  Такое  построение эмулятора дает возможность лекго его
модернизировать и использовать в других программах как встроенный.

   в)Дебуггер.
  Деббугер  был  построен  на  основе  модулей  эмулятора, поэтому обладает
такими   же   параметрами   как  и  эмулятор.  Дебуггер  имеет  собственный
конфигурационный  файл.  Кроме  того, в дебуггере я сделал функцию, которая
позволяет  дизассемблировать исполняемый файл и сохранить в виде текстового
файла  с  текстом  ассемблерной программы. При дизассемблировании созданный
текст дополняется комментариями на английском языке. Дебуггер имет скромные
возможности,  так  как  делал  его,  я  прежде  всего  для  изучения работы
виртуальной машины. Это возможно, так как дебуггер отображает все изменения
которые происходят с регистрами и флагами.
  При  написании  дебуггера  для  построение  интерфейса я использовал свой
модуль  который  позволяет  создавать  интерфейс подобный Turbo Vision. Это
связанно  с  тем,  что даже примитивная программа использующая Turbo Vision
занимает  не  менее  70  килобайт,  что  сильно  много  для дебуггер размер
которого и без того больше 220 килобайт.









