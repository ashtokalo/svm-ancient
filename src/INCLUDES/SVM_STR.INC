 ;---------------------------------------------------------------------------
 ;                                SVM Strings
 ;                                Version 1.0
 ;                      Copyright (C) 1999 ShAG Studio
 ;---------------------------------------------------------------------------
 ;    Это   демо-версия   подключаемой   библиотеки,   которую   вы   можете
 ; использовать  для  написания  программ на SVM Ассемблере версии 1.0. Файл
 ; содержит   процедуры   для   работы  с  ASCIIZ  строками,  т.е.  строками
 ; заканчивающимися байтом равным 0. Наприммер:
 ;
 ;  String DB 'Example string',0
 ;
 ;    Внимание! Все процедуры вывода строк на экран работают ТОЛЬКО в версии
 ; 1.0  и небудут работать в последующих версиях. В данной версии они включе
 ; ны  только  для  демонстрации  возможностей  и  теста  работоспособности!
 ; Поэтому  для  избежания  недорозумений  ПРИДУПРЕЖАЮ  в дальнейших версиях
 ; будут  работать  только  процедуры  производящии  какие-то  изменения над
 ; строками.
 ;---------------------------------------------------------------------------
 ; Список процедура для работы со строками:
 ;  WriteString   - выводит строку
 ;  CopyString    - копирует строку
 ;  StrLength     - возвращает длинну строки
 ;  ConcatString  - соединяет две строки
 ;  NumToString   - переводит число в ASCIIZ строку
 ;---------------------------------------------------------------------------
 ; Дальше идут константы и переменные
 ;---------------------------------------------------------------------------

 NewString DB 10,13,0 ;Строка переводит курсор на следующюю строку

 ;---------------------------------------------------------------------------
 ; WriteString - выводит строку на экран
 ;---------------------------------------------------------------------------
 ; Вход:
 ;  EP - адрес текстовой строки
 ; Выход:
 ;  строка выводится на экран
 ; Регистры:
 ;  нет
 ;---------------------------------------------------------------------------
 PROC WriteString
  PUSH AL               ; Сохраняем используемые регистры
  PUSH CX
  MOV CX, 0             ; Устанавливаем счетчик в 0
 @REPEAT:
  MOV AL, [EP+CX]       ; Берем байт из строки и проверяем,
  CMP AL, 0             ; если он - сигнал конца строки, то
  JE  @EXIT             ; выходим из процедуры, заканчивая вывод, иначе
  CSP 1                 ; выводим символ и
  INC CX                ; увеличиваем счетчик на 1, после чего
  JMP @REPEAT           ; продолжаем выводить следующие символы
 @EXIT:
  POP CX                ; Востанавливаем первоначальное значение регистров
  POP AL
 RET

 ;---------------------------------------------------------------------------
 ; CopyString - копирует строку с одного места на другое
 ;---------------------------------------------------------------------------
 ; Вход:
 ;  FP - Адрес строки источника
 ;  EP - Адрес строки назначения
 ; Выход:
 ;  Строка начинающаяся по адресу FP копируется в адресс EP
 ; Регистры:
 ;  нет
 ;---------------------------------------------------------------------------
 PROC CopyString
  PUSH AL               ; Сохраняем используемые регистры
  PUSH CX
  MOV CX, 0             ; Устанавливаем номер копируемого байта в 0
 @REPEAT:
  MOV AL, [FP+CX]       ; Берем байт с одного адреса и записываем по
  MOV [EP+CX], AL       ; новому адресу
  CMP AL, 0             ; Если переносимый байт - сигнал конца строки,
  JE  @EXIT             ; то выходим из процедуры,
  INC CX                ; иначе, увеличиваем счетчик на 1 и продолжаем
  JMP @REPEAT           ; копировать
 @EXIT:
  POP CX                ; Востанавливаем первоначальное значение регистров
  POP AL
 RET

 ;---------------------------------------------------------------------------
 ; StrLength - возвращает длинну строки
 ;---------------------------------------------------------------------------
 ; Вход:
 ;  EP - Адрес строки источника
 ; Выход:
 ;  CX - содержит длинну строки без учета последнего нуля
 ; Регистры:
 ;  CX
 ;---------------------------------------------------------------------------
 PROC StrLength
  PUSH AL               ; Сохранияем используемый регистр
  MOV CX, 0             ; Длинна равна 0
 @REPEAT:
  MOV AL, [EP+CX]       ; Проверяем, если байт по адресу EP+CX равен 0,
  CMP AL, 0             ; то выходим из процедуры, а в CX получаем длинну
  JE  @NEXT             ; иначе увеличиваем количество символов на 1
  INC CX                ;
  JMP @REPEAT
 @NEXT:
  POP AL                ; Востанавливаем использованный регистр
 RET

 ;---------------------------------------------------------------------------
 ; ConcatString - прибавляет в конец одной строки другую
 ;---------------------------------------------------------------------------
 ; Вход:
 ;  EP - Адрес главной строки
 ;  FP - Адрес прибавляемой строки
 ; Выход:
 ;  В конец строки EP прибавляется строка FP
 ; Регистры:
 ;  нет
 ;---------------------------------------------------------------------------
 PROC ConcatString
  PUSH EP             ; Сохраняем используемые регистры
  PUSH FP
  CALL StrLength         ; Получаем длинну строки
  ADD EP, CX          ; Копируем строку содержащююся по адресу FP в
  CALL CopyString     ; конец строки содержащейся по адресу EP
  POP FP              ; Востанавливаем первоначальное значение регистров
  POP EP
 RET

 ;---------------------------------------------------------------------------
 ; NumToString - переводит число в ASCIIZ строку
 ;---------------------------------------------------------------------------
 ; Вход:
 ;  EP  - Адрес строки куда будет записанно число
 ;  LAX - Число которое надо перевести
 ; Выход:
 ;  В строку по адресу EP записывается число заданное в LAX
 ; Регистры:
 ;  нет
 ;---------------------------------------------------------------------------
 PROC NumToString
  PUSH LAX                ; сохраняем используемые регистры
  PUSH LBX
  PUSH LCX
  PUSH LDX
  MOV  BL, 0              ; bl  - счетчик цифр
  CMP  LAX, 0             ; проверяем, если число отрицательное, то
  JNL  @Next_test         ; записываем в строку -, и меняем знак на
  MOV  [EP], 45           ; противоположный
  INC  BL
  NEG  LAX
 @Next_test:
  MOV  LDX, LAX           ; ldx - основное число
  MOV  LCX, 1000000000000000000; lcx - делитель, максимальное 64-битное число
  CLA                     ; устанавливаем флаг A пустым
  JMP  @First_detect      ; первый раз не уменьшаем делитель
 @Detect:
  DIV  LCX, 10            ; уменьшаем делитель на порядок
 @First_detect:
  CMP  LCX, 0             ; проверяем если дилитель равен нулю, то
  JE   @End               ; выходим из процедуры
  MOV  LAX, LDX           ; заносим основное число в lax
  DIV  LAX, LCX           ; делим lax на делитель
  JA   @Next              ; если флаг A установлен делаем переход
  CMP  LAX, 0             ; иначе сравниваем результат деления с нулем
  JE   @Detect            ; если равен нулю то его можно пропустить, т.к. первая цифра не ноль
 @Next:
  STA                     ; исли флаг не равен нулю устанавливаем флаг A - первая цифра есть
  ADD  AL, 48             ; добовляем к результату деления 48, чтобы получит ASCII код
  MOV  [EP+BL], AL        ; помещаем ASCII код цифры по адресу строки
  INC  BL                 ; увеличиваем счетчик цифр
  SUB  AL, 48             ; востанавливаем al
  MUL  LAX, LCX           ; в ldx помещаем остаток от деления
  SUB  LDX, LAX           ;
  CMP  LDX, 0             ; проверяем, если ldx меньше нуля, то выходим из
  JL   @End               ; процедуры,
  JMP  @Detect            ; иначе продолжаем разбор
 @End:
  MOV  [EP+BL], 0         ; завершаем текстовую строку нулем
  POP  LDX                ; востанавливаем первоночальные регистры
  POP  LCX
  POP  LBX
  POP  LAX
 RET

 ;---------------------------------------------------------------------------
 ;                                SVM Strings
 ;---------------------------------------------------------------------------